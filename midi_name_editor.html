<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MIDI Name Editor</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #f5f5f5;
            color: #333;
        }

        .header {
            background: #2c3e50;
            color: white;
            padding: 1rem;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .header h1 {
            font-size: 1.5rem;
            font-weight: 600;
        }

        .tabs {
            display: flex;
            background: white;
            border-bottom: 1px solid #ddd;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
            justify-content: space-between;
            align-items: center;
        }

        .tab {
            padding: 1rem 1.5rem;
            cursor: pointer;
            border-bottom: 3px solid transparent;
            transition: all 0.2s;
            font-weight: 500;
        }

        .tab:hover {
            background: #f8f9fa;
        }

        .tab.active {
            border-bottom-color: #3498db;
            color: #3498db;
            background: white;
        }

        .tab-content {
            display: none;
            padding: 2rem;
            background: white;
            min-height: calc(100vh - 120px);
        }

        .tab-content.active {
            display: block;
        }

        /* Global MIDI Controls - Upper Right */
        .global-midi-controls {
            position: fixed;
            top: 1rem;
            right: 1rem;
            z-index: 1000;
            display: flex;
            align-items: center;
            gap: 0.75rem;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            padding: 0.75rem 1rem;
            border-radius: 25px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            border: 1px solid rgba(255, 255, 255, 0.2);
            min-width: 280px;
        }

        .midi-toggle {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            cursor: pointer;
            padding: 0.25rem 0.5rem;
            border-radius: 15px;
            transition: all 0.3s ease;
            user-select: none;
        }

        .midi-toggle:hover {
            background: rgba(0, 0, 0, 0.05);
        }

        .midi-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #dc3545;
            transition: all 0.3s ease;
            position: relative;
        }

        .midi-dot.enabled {
            background: #28a745;
            box-shadow: 0 0 8px rgba(40, 167, 69, 0.4);
        }

        .midi-dot.enabled::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 6px;
            height: 6px;
            background: white;
            border-radius: 50%;
        }

        .midi-label {
            font-size: 0.875rem;
            font-weight: 500;
            color: #495057;
        }

        .midi-device-section {
            display: flex;
            flex-direction: column;
            gap: 0.25rem;
            flex: 1;
        }

        .midi-device-select {
            padding: 0.375rem 0.5rem;
            border: 1px solid #ddd;
            border-radius: 6px;
            font-size: 0.8rem;
            background: white;
            min-width: 180px;
        }

        .midi-device-select:disabled {
            background: #f8f9fa;
            color: #6c757d;
        }

        .midi-device-info {
            font-size: 0.7rem;
            color: #6c757d;
            font-weight: 500;
        }

        .midi-device-info.connected {
            color: #28a745;
        }

        /* Hide MIDI controls on debug tabs */
        .tab[data-tab="debug"] ~ .global-midi-controls {
            display: none;
        }

        .btn-compact {
            padding: 0.5rem 1rem;
            font-size: 0.9rem;
        }

        .patch-program-change-btn {
            background: #007AFF;
            color: white;
            border: none;
            padding: 0.25rem 0.5rem;
            border-radius: 3px;
            font-size: 0.85rem;
            cursor: pointer;
            transition: background 0.2s;
            font-family: monospace;
        }

        .patch-program-change-btn:hover {
            background: #0056CC;
        }

        .bank-select-info {
            margin-top: 0.5rem;
            padding: 0.5rem;
            background: #f8f9fa;
            border-radius: 4px;
            border: 1px solid #e9ecef;
        }

        .bank-select-commands {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            margin-top: 0.5rem;
        }

        .bank-select-command {
            display: flex;
            align-items: center;
            gap: 0.25rem;
            padding: 0.25rem 0.5rem;
            background: #e9ecef;
            border-radius: 3px;
            font-family: monospace;
            font-size: 0.85rem;
        }

        .bank-select-btn {
            background: #007AFF;
            color: white;
            border: none;
            padding: 0.25rem 0.5rem;
            border-radius: 3px;
            font-size: 0.85rem;
            cursor: pointer;
            transition: background 0.2s;
            margin-left: 0.5rem;
        }

        .bank-select-btn:hover {
            background: #0056CC;
        }

        .bank-select-btn:disabled {
            background: #ccc;
            cursor: not-allowed;
        }

        .bank-select-summary {
            padding: 0.5rem 1rem;
            background: #f8f9fa;
            border-top: 1px solid #e9ecef;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 0.5rem;
        }

        .bank-select-preview {
            font-size: 0.9rem;
            color: #495057;
            font-family: monospace;
        }

        .bank-select-summary .bank-select-btn {
            margin: 0;
            padding: 0.25rem 0.5rem;
            font-size: 0.8rem;
        }

        .form-group {
            margin-bottom: 1.5rem;
        }

        .form-group label {
            display: block;
            margin-bottom: 0.5rem;
            font-weight: 600;
            color: #555;
        }

        .form-group input,
        .form-group select {
            width: 100%;
            padding: 0.75rem;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 1rem;
        }

        .form-group input:focus,
        .form-group select:focus {
            outline: none;
            border-color: #3498db;
            box-shadow: 0 0 0 2px rgba(52, 152, 219, 0.2);
        }

        .btn {
            padding: 0.75rem 1.5rem;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 1rem;
            font-weight: 500;
            transition: all 0.2s;
        }

        .btn-primary {
            background: #3498db;
            color: white;
        }

        .btn-primary:hover {
            background: #2980b9;
        }

        .btn-secondary {
            background: #95a5a6;
            color: white;
        }

        .btn-secondary:hover {
            background: #7f8c8d;
        }

        .btn-success {
            background: #27ae60;
            color: white;
        }

        .btn-success:hover {
            background: #229954;
        }

        .manufacturer-dropdown {
            position: relative;
            margin-top: 1rem;
        }

        .manufacturer-input {
            width: 100%;
            padding: 0.75rem;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 1rem;
        }

        .manufacturer-dropdown-list {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: white;
            border: 1px solid #ddd;
            border-top: none;
            border-radius: 0 0 4px 4px;
            max-height: 300px;
            overflow-y: auto;
            z-index: 1000;
            display: none;
        }

        .manufacturer-dropdown-list.show {
            display: block;
        }

        .manufacturer-option {
            padding: 0.75rem;
            cursor: pointer;
            border-bottom: 1px solid #f0f0f0;
        }

        .manufacturer-option:hover {
            background: #f8f9fa;
        }

        .manufacturer-option.selected {
            background: #e3f2fd;
            color: #1976d2;
        }

        .manufacturer-name {
            font-weight: 600;
            margin-bottom: 0.25rem;
        }

        .manufacturer-stats {
            font-size: 0.8rem;
            color: #666;
            font-style: italic;
        }

        .manufacturer-details {
            background: white;
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 1.5rem;
            margin-top: 1rem;
            display: none;
        }

        .manufacturer-details.show {
            display: block;
        }

        .manufacturer-info {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1rem;
            margin-bottom: 1.5rem;
        }

        .info-item {
            background: #f8f9fa;
            padding: 0.75rem;
            border-radius: 4px;
        }

        .info-label {
            font-size: 0.9rem;
            color: #666;
            margin-bottom: 0.25rem;
        }

        .info-value {
            font-weight: 600;
            font-family: monospace;
        }

        .device-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 1rem;
            background: white;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .device-table th {
            background: #f8f9fa;
            padding: 1rem;
            text-align: left;
            font-weight: 600;
            border-bottom: 2px solid #dee2e6;
        }

        .device-table td {
            padding: 1rem;
            border-bottom: 1px solid #dee2e6;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .device-table tr:hover td {
            background: #f8f9fa;
        }

        .device-table tr.selected td {
            background: #e3f2fd;
            color: #1976d2;
        }

        .device-name {
            font-weight: 600;
        }

        .device-type {
            font-size: 0.9rem;
            color: #666;
        }

        .device-capabilities {
            font-size: 0.85rem;
            color: #666;
        }

        .capability-tag {
            display: inline-block;
            background: #e9ecef;
            color: #495057;
            padding: 0.25rem 0.5rem;
            border-radius: 12px;
            font-size: 0.75rem;
            margin: 0.125rem;
        }

        .capability-tag.active {
            background: #d4edda;
            color: #155724;
        }

        .structure-editor {
            background: white;
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 1.5rem;
        }

        .structure-item {
            background: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 4px;
            padding: 1rem;
            margin-bottom: 1rem;
        }

        .structure-item h3 {
            margin-bottom: 0.5rem;
            color: #495057;
        }

        .device-info-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1rem;
            margin-top: 1rem;
        }

        .structure-section {
            margin-bottom: 2rem;
        }

        .structure-section h4 {
            margin-bottom: 1rem;
            color: #495057;
            border-bottom: 1px solid #dee2e6;
            padding-bottom: 0.5rem;
        }

        .structure-element {
            background: white;
            border: 1px solid #dee2e6;
            border-radius: 4px;
            margin-bottom: 0.5rem;
            overflow: hidden;
        }

        .element-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.75rem 1rem;
            background: #f8f9fa;
            border-bottom: 1px solid #dee2e6;
        }

        .element-name {
            font-weight: 600;
            color: #495057;
        }

        .element-actions {
            display: flex;
            gap: 0.5rem;
        }

        .element-content {
            padding: 1rem;
            color: #666;
        }

        .empty-state {
            text-align: center;
            color: #999;
            font-style: italic;
            padding: 2rem;
            background: #f8f9fa;
            border: 2px dashed #dee2e6;
            border-radius: 4px;
            margin-bottom: 1rem;
        }

        .btn-danger {
            background: #dc3545;
            color: white;
        }

        .btn-danger:hover {
            background: #c82333;
        }

        .structure-actions {
            display: flex;
            gap: 0.5rem;
            margin-top: 1rem;
        }

        .btn-small {
            padding: 0.5rem 1rem;
            font-size: 0.9rem;
        }

        .note-editor-controls {
            background: #f8f9fa;
            padding: 1rem;
            border-radius: 4px;
            margin: 1rem 0;
        }

        .note-editor-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
            padding-bottom: 0.5rem;
            border-bottom: 1px solid #dee2e6;
        }

        .note-editor-actions {
            display: flex;
            gap: 0.5rem;
        }

        .note-table-container {
            background: white;
            border: 1px solid #dee2e6;
            border-radius: 4px;
            overflow: hidden;
        }

        .note-table {
            width: 100%;
            border-collapse: collapse;
        }

        .note-table th {
            background: #f8f9fa;
            padding: 0.75rem;
            text-align: left;
            font-weight: 600;
            border-bottom: 1px solid #dee2e6;
        }

        .note-table td {
            padding: 0.75rem;
            border-bottom: 1px solid #f0f0f0;
        }

        .note-table tr:last-child td {
            border-bottom: none;
        }

        /* Piano key styling */
        .note-table tr.black-key {
            background-color: #f0f0f0;
        }

        .note-table tr.black-key .note-number-cell {
            background: #333333;
            color: white;
            border: 2px solid #000;
        }

        .note-table tr.black-key .note-number-cell:hover {
            background: #555555;
        }

        .note-table tr.middle-c {
            background-color: #fff3cd;
            border-left: 4px solid #ffc107;
        }

        .note-table tr.middle-c .note-number-cell {
            background: #ffeaa7;
            font-weight: bold;
            color: #856404;
        }

        .note-number-cell {
            font-family: monospace;
            text-align: center;
            background: #007AFF;
            color: white;
            padding: 8px;
            border-radius: 4px;
            cursor: pointer;
            transition: background 0.2s;
            width: 80px;
            border: none;
            font-size: 12px;
            font-weight: 500;
        }

        .note-number-cell:hover {
            background: #0056CC;
        }

        .note-number-cell.playable {
            background: #17a2b8;
            border: 1px solid #138496;
        }

        .note-number-cell.playable:hover {
            background: #138496;
        }

        .play-note-btn {
            background: #17a2b8;
            font-size: 12px;
            padding: 4px 8px;
            min-width: 60px;
        }

        .play-note-btn:hover {
            background: #138496;
        }

        /* Note actions styling */
        .note-actions {
            text-align: center;
            white-space: nowrap;
        }

        .note-actions .btn {
            margin: 0 2px;
            min-width: 32px;
            height: 32px;
            padding: 0;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            font-weight: bold;
        }

        .add-note-btn {
            background: #28a745;
            border-color: #28a745;
            color: white;
        }

        .add-note-btn:hover {
            background: #218838;
            border-color: #1e7e34;
        }

        .remove-note-btn {
            background: #dc3545;
            border-color: #dc3545;
            color: white;
        }

        .remove-note-btn:hover {
            background: #c82333;
            border-color: #bd2130;
        }

        /* Note name dropdown styling */
        .note-name-cell {
            position: relative;
        }

        .note-dropdown {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: white;
            border: 1px solid #ddd;
            border-top: none;
            max-height: 200px;
            overflow-y: auto;
            z-index: 1000;
            display: none;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        .note-dropdown-item {
            padding: 8px 12px;
            cursor: pointer;
            border-bottom: 1px solid #f0f0f0;
            font-size: 14px;
        }

        .note-dropdown-item:hover {
            background: #f0f0f0;
        }

        .note-dropdown-item.selected {
            background: #007AFF;
            color: white;
        }

        .note-dropdown-item:last-child {
            border-bottom: none;
        }


        .keyboard-tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 12px;
            z-index: 1000;
            pointer-events: none;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .keyboard-tooltip img {
            filter: invert(1);
        }

        .patch-selection-list {
            margin-top: 1rem;
        }

        .patch-bank-section {
            margin-bottom: 1.5rem;
        }

        .patch-bank-section h5 {
            margin: 0 0 0.5rem 0;
            color: #666;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .patch-selection-item {
            display: flex;
            align-items: center;
            gap: 1rem;
            padding: 0.75rem;
            margin-bottom: 0.5rem;
            background: white;
            border: 1px solid #ddd;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .patch-selection-item:hover {
            background: #f8f9fa;
            border-color: #007AFF;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .patch-selection-item .patch-number {
            font-family: monospace;
            font-weight: bold;
            color: #007AFF;
            min-width: 40px;
        }

        .patch-selection-item .patch-name {
            flex: 1;
            font-weight: 500;
        }

        .patch-selection-item .patch-program-change {
            font-family: monospace;
            color: #666;
            font-size: 0.9rem;
        }

        /* File Disambiguation Dialog */
        .file-comparison {
            margin: 1rem 0;
        }

        .comparison-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 1rem;
        }

        .comparison-table th,
        .comparison-table td {
            padding: 0.75rem;
            text-align: left;
            border-bottom: 1px solid #dee2e6;
        }

        .comparison-table th {
            background: #f8f9fa;
            font-weight: 600;
            color: #495057;
        }

        .comparison-table tr:hover {
            background-color: #f8f9fa;
        }

        .file-path {
            font-family: monospace;
            font-size: 0.9rem;
            color: #666;
        }

        .file-size {
            font-size: 0.9rem;
            color: #666;
        }

        .file-modified {
            font-size: 0.9rem;
            color: #666;
        }

        .action-buttons {
            display: flex;
            gap: 0.5rem;
        }

        .btn-tiny {
            padding: 0.25rem 0.5rem;
            font-size: 0.8rem;
        }

        .keyboard-tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 12px;
            z-index: 1000;
            pointer-events: none;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .keyboard-tooltip img {
            filter: invert(1);
        }

        .note-number-input,
        .note-name-input {
            width: 100%;
            padding: 0.5rem;
            border: 1px solid #ddd;
            border-radius: 3px;
            font-size: 0.9rem;
        }

        .note-number-input:focus,
        .note-name-input:focus {
            outline: none;
            border-color: #3498db;
            box-shadow: 0 0 0 2px rgba(52, 152, 219, 0.2);
        }

        .patch-editor {
            margin-top: 1rem;
        }

        .patch-controls {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 1rem;
        }

        .patch-list {
            border: 1px solid #dee2e6;
            border-radius: 4px;
            overflow: hidden;
        }

        .patch-item {
            border-bottom: 1px solid #f0f0f0;
        }

        .patch-item:last-child {
            border-bottom: none;
        }

        .patch-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.75rem 1rem;
            background: #f8f9fa;
            border-bottom: 1px solid #e9ecef;
        }

        .patch-info-inline {
            display: flex;
            align-items: center;
            gap: 1rem;
            font-size: 0.9rem;
        }

        .patch-number {
            font-weight: 600;
            color: #007bff;
            background: #e3f2fd;
            padding: 2px 6px;
            border-radius: 3px;
        }

        .patch-name {
            font-weight: 500;
            color: #333;
        }

        .patch-program-change {
            color: #666;
            font-size: 0.85rem;
        }

        .patch-name {
            font-weight: 600;
            color: #495057;
        }

        .patch-number {
            font-family: monospace;
            color: #666;
            margin-left: 0.5rem;
        }

        .patch-actions {
            display: flex;
            gap: 0.5rem;
        }

        .patch-details {
            padding: 1rem;
            background: white;
        }

        .patch-info {
            margin-bottom: 1rem;
            color: #666;
        }

        .patch-note-lists {
            border-top: 1px solid #f0f0f0;
            padding-top: 1rem;
        }

        .note-list-reference {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0.5rem;
            background: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 4px;
            margin-bottom: 0.5rem;
        }

        .note-list-reference .note-list-name {
            font-weight: 500;
            color: #495057;
        }

        /* Visual hierarchy improvements */
        .structure-section {
            margin-bottom: 2rem;
            border: 1px solid #e9ecef;
            border-radius: 8px;
            padding: 1.5rem;
            background: #fafbfc;
        }

        .structure-section h4 {
            margin: 0 0 1rem 0;
            color: #495057;
            font-size: 1.1rem;
            border-bottom: 2px solid #007bff;
            padding-bottom: 0.5rem;
        }

        .structure-element {
            margin-left: 1rem;
            border-left: 3px solid #dee2e6;
            padding-left: 1rem;
            margin-bottom: 1rem;
        }

        .patch-item {
            margin-left: 2rem;
            border-left: 3px solid #007bff;
            padding-left: 1rem;
            margin-bottom: 0.5rem;
        }

        .note-list-reference {
            margin-left: 3rem;
            border-left: 3px solid #28a745;
            padding-left: 1rem;
        }

        /* Expandable elements */
        .expandable {
            cursor: pointer;
            user-select: none;
        }

        .expandable:hover {
            background-color: #f8f9fa;
            border-radius: 4px;
            padding: 2px 4px;
        }

        .expand-icon {
            display: inline-block;
            width: 12px;
            margin-right: 8px;
            font-size: 10px;
            color: #666;
        }

        /* Modal styles for device selection */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10000;
        }

        .modal-content {
            background: white;
            border-radius: 8px;
            padding: 2rem;
            max-width: 600px;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
        }

        .modal-content h3 {
            margin: 0 0 1rem 0;
            color: #333;
        }

        .device-selection-list {
            margin: 1rem 0;
        }

        .device-selection-item {
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 1rem;
            margin-bottom: 0.5rem;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .device-selection-item:hover {
            background: #f8f9fa;
            border-color: #007bff;
        }

        .file-selection-list {
            max-height: 400px;
            overflow-y: auto;
            margin-bottom: 1rem;
        }

        .file-selection-item {
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 1rem;
            margin-bottom: 0.5rem;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .file-selection-item:hover {
            background: #f8f9fa;
            border-color: #007bff;
        }

        .file-node-counts {
            display: flex;
            gap: 1rem;
            margin-top: 0.5rem;
            font-size: 0.9rem;
            color: #666;
        }

        .file-node-counts span {
            background: #f8f9fa;
            padding: 0.25rem 0.5rem;
            border-radius: 3px;
            border: 1px solid #e9ecef;
        }

        .file-node-counts .count-label {
            font-weight: 600;
            color: #495057;
        }

        .file-author {
            font-size: 0.9rem;
            color: #666;
            margin-top: 0.25rem;
            font-style: italic;
        }

        .file-selection-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.5rem;
        }

        .file-path {
            font-size: 0.9rem;
            color: #666;
            font-family: monospace;
        }

        /* Builder tab styles */
        .builder-section {
            margin-bottom: 2rem;
            border: 1px solid #e9ecef;
            border-radius: 8px;
            padding: 1.5rem;
            background: #fafbfc;
        }

        .builder-section h3 {
            margin: 0 0 1rem 0;
            color: #495057;
            font-size: 1.1rem;
            border-bottom: 2px solid #28a745;
            padding-bottom: 0.5rem;
        }

        .device-selection {
            margin-bottom: 1rem;
        }

        .device-selection label {
            display: block;
            margin-bottom: 0.5rem;
            font-weight: 600;
            color: #333;
        }

        .device-selection select {
            width: 100%;
            max-width: 400px;
            padding: 0.75rem;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 1rem;
            background: white;
        }

        .device-info {
            background: #e8f5e8;
            border: 1px solid #c3e6c3;
            border-radius: 4px;
            padding: 1rem;
            margin-top: 1rem;
        }

        .expansion-cards {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 1rem;
        }

        .expansion-card {
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 1rem;
            background: white;
            cursor: pointer;
            transition: all 0.2s;
        }

        .expansion-card:hover {
            border-color: #007bff;
            box-shadow: 0 2px 4px rgba(0, 123, 255, 0.1);
        }

        .expansion-card.selected {
            border-color: #28a745;
            background: #f8fff8;
        }

        .expansion-card input[type="checkbox"] {
            margin-right: 0.5rem;
        }

        .expansion-card h4 {
            margin: 0 0 0.5rem 0;
            color: #333;
        }

        .expansion-card p {
            margin: 0;
            color: #666;
            font-size: 0.9rem;
        }

        .preview-section {
            background: white;
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 1rem;
            min-height: 200px;
        }

        .build-actions {
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .build-actions input {
            padding: 0.75rem;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 1rem;
        }

        .device-selection-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.5rem;
        }

        .match-type {
            background: #e9ecef;
            color: #495057;
            padding: 0.25rem 0.5rem;
            border-radius: 3px;
            font-size: 0.8rem;
            text-transform: uppercase;
        }

        .device-selection-files {
            margin-top: 0.5rem;
        }

        .file-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.25rem 0;
            font-size: 0.9rem;
            color: #666;
        }

        .file-path {
            font-family: monospace;
            flex: 1;
            margin-right: 1rem;
        }

        .file-size {
            color: #888;
        }

        .modal-actions {
            margin-top: 1.5rem;
            text-align: right;
        }

        /* Catalog tab styles */
        .catalog-controls {
            display: flex;
            gap: 1rem;
            align-items: center;
            margin-bottom: 1rem;
            padding: 1rem;
            background: #f8f9fa;
            border-radius: 8px;
        }

        .status-text {
            color: #666;
            font-style: italic;
        }

        .catalog-content {
            background: white;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .catalog-table {
            width: 100%;
            border-collapse: collapse;
        }

        .catalog-table th {
            background: #f8f9fa;
            padding: 1rem;
            text-align: left;
            font-weight: 600;
            border-bottom: 2px solid #dee2e6;
            position: sticky;
            top: 0;
        }

        .catalog-table td {
            padding: 0.75rem 1rem;
            border-bottom: 1px solid #dee2e6;
            vertical-align: top;
        }

        .catalog-table tr:hover {
            background: #f8f9fa;
        }

        .device-key {
            font-family: monospace;
            font-weight: bold;
            color: #007bff;
        }

        .file-list {
            font-size: 0.9rem;
        }

        .file-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.25rem 0;
            border-bottom: 1px solid #f0f0f0;
        }

        .file-item:last-child {
            border-bottom: none;
        }

        .file-path {
            font-family: monospace;
            color: #666;
            flex: 1;
            margin-right: 1rem;
        }

        .file-size {
            color: #888;
            font-size: 0.8rem;
        }

        .device-type {
            display: inline-block;
            padding: 0.25rem 0.5rem;
            border-radius: 3px;
            font-size: 0.8rem;
            text-transform: uppercase;
            font-weight: bold;
        }

        .device-type.master {
            background: #d4edda;
            color: #155724;
        }

        .device-type.extending {
            background: #fff3cd;
            color: #856404;
        }

        .loading {
            text-align: center;
            padding: 2rem;
            color: #666;
        }

        /* Patch selection styles */
        .patch-selection {
            background: #f8f9fa;
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1rem;
        }

        .patch-selection label {
            display: block;
            margin-bottom: 0.5rem;
            font-weight: 600;
            color: #333;
        }

        .patch-selection select {
            width: 100%;
            padding: 0.75rem;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 1rem;
            background: white;
        }

        .patch-selection select:focus {
            outline: none;
            border-color: #007bff;
            box-shadow: 0 0 0 2px rgba(0, 123, 255, 0.25);
        }

        .note-list-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.5rem;
            background: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 3px;
            margin-bottom: 0.5rem;
        }

        .note-list-name {
            font-weight: 500;
            color: #495057;
        }

        .note-list-actions {
            display: flex;
            gap: 0.5rem;
        }

        .hidden {
            display: none;
        }

        .loading {
            text-align: center;
            padding: 2rem;
            color: #666;
        }

        .error {
            background: #f8d7da;
            color: #721c24;
            padding: 1rem;
            border-radius: 4px;
            margin: 1rem 0;
        }

        .success {
            background: #d4edda;
            color: #155724;
            padding: 1rem;
            border-radius: 4px;
            margin: 1rem 0;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>MIDI Name Editor</h1>
    </div>

    <div class="tabs">
        <div class="tab active" data-tab="manufacturer">Manufacturer</div>
        <div class="tab" data-tab="device">Device</div>
        <div class="tab" data-tab="patch">Patch</div>
        <div class="tab" data-tab="builder">Builder</div>
        <div class="tab" data-tab="catalog">Catalog</div>
        
        <!-- Global MIDI Controls - Fixed Upper Right -->
        <div class="global-midi-controls" id="global-midi-controls">
            <div class="midi-toggle" id="midi-toggle" onclick="toggleMIDI()">
                <div class="midi-dot" id="midi-dot"></div>
                <span class="midi-label" id="midi-label">MIDI</span>
            </div>
            <div class="midi-device-section">
                <select id="midi-device-select" class="midi-device-select" disabled onchange="selectMIDIDevice()">
                    <option value="">Select a MIDI Device</option>
                </select>
                <div class="midi-device-info" id="midi-device-info">Not connected</div>
            </div>
        </div>
    </div>

    <!-- Manufacturer Selection Tab -->
    <div class="tab-content active" id="manufacturer-tab">
        <h2>Select Manufacturer</h2>
        <p>Choose a manufacturer to get started with creating or editing a MIDI name document.</p>
        
        <div class="form-group">
            <label for="manufacturer-input">Manufacturer:</label>
            <div class="manufacturer-dropdown">
                <input type="text" id="manufacturer-input" placeholder="Type to search manufacturers..." autocomplete="off">
                <div class="manufacturer-dropdown-list" id="manufacturer-dropdown-list"></div>
            </div>
        </div>

        <div class="manufacturer-details" id="manufacturer-details">
            <div class="manufacturer-info">
                <div class="info-item">
                    <div class="info-label">Manufacturer ID</div>
                    <div class="info-value" id="manufacturer-id">-</div>
                </div>
                <div class="info-item">
                    <div class="info-label">Device Count</div>
                    <div class="info-value" id="device-count">-</div>
                </div>
            </div>
            
            <h3>Available Devices</h3>
            <table class="device-table" id="device-table">
                <thead>
                    <tr>
                        <th>Model</th>
                        <th>Type</th>
                        <th>Capabilities</th>
                    </tr>
                </thead>
                <tbody id="device-table-body">
                </tbody>
            </table>
            
            <div class="structure-actions" style="margin-top: 1rem;">
                <button class="btn btn-primary" id="create-new-device">Create New Device</button>
            </div>
        </div>

        <div class="loading" id="manufacturer-loading">Loading manufacturers...</div>
    </div>

    <!-- Device Editor Tab -->
    <div class="tab-content" id="device-tab">
        <h2>Device Configuration</h2>
        <div id="device-info">
            <p>Selected Manufacturer: <strong id="selected-manufacturer">None</strong></p>
            <p>Selected Device: <strong id="selected-device">None</strong></p>
        </div>
        
        <div class="structure-editor" id="structure-editor">
            <div class="loading">Select a device from the Manufacturer tab to edit its configuration</div>
        </div>
        
        <div class="structure-actions">
            <button class="btn btn-success" id="save-structure">Save Configuration</button>
            <button class="btn btn-secondary" id="validate-structure">Validate</button>
        </div>
    </div>

    <!-- Patch Editor Tab -->
    <div class="tab-content" id="patch-tab">
        <h2>Patch Configuration</h2>
        <div id="patch-info">
            <p>Selected Device: <strong id="selected-device-notes">None</strong></p>
            <p>Selected Patch: <strong id="selected-patch">None</strong></p>
            <p>Configure patch settings and note name mappings for the selected patch.</p>
        </div>
        
        
        <!-- Patch Selection Dropdown -->
        <div class="patch-selection">
            <label for="patch-select">Select Patch:</label>
            <select id="patch-select" onchange="switchPatch(this.value)">
                <option value="">Select a patch...</option>
            </select>
        </div>
        
        <div id="patch-editor-container">
            <div class="loading">Select a patch from the Device tab to edit its configuration</div>
        </div>
        
        <div class="structure-actions">
            <button class="btn btn-success" id="save-patch">Save Patch</button>
            <button class="btn btn-secondary" id="validate-patch">Validate</button>
        </div>
    </div>

    <!-- Catalog Debug Tab -->
    <div class="tab-content" id="catalog-tab">
        <h2>MIDI Name Document Catalog</h2>
        <div class="catalog-controls">
            <button class="btn btn-primary" onclick="loadCatalog()">Refresh Catalog</button>
            <button class="btn btn-secondary" onclick="clearCatalogCache()">Clear Cache</button>
            <span id="catalog-status" class="status-text"></span>
        </div>
        <div id="catalog-content">
            <div class="loading">Loading catalog...</div>
        </div>
    </div>

    <!-- Custom .midnam Builder Tab -->
    <div class="tab-content" id="builder-tab">
        <h2>Custom .midnam Builder</h2>
        <p>Build custom .midnam files by combining base devices with expansion cards.</p>
        
        <!-- Device Selection -->
        <div class="builder-section">
            <h3>Base Device</h3>
            <div class="device-selection">
                <label for="base-device-select">Select Base Device:</label>
                <select id="base-device-select" onchange="selectBaseDevice(this.value)">
                    <option value="">Choose a device...</option>
                </select>
            </div>
            <div id="base-device-info" class="device-info" style="display: none;">
                <h4 id="base-device-name"></h4>
                <p id="base-device-description"></p>
            </div>
        </div>
        
        <!-- Expansion Cards -->
        <div class="builder-section">
            <h3>Expansion Cards</h3>
            <div id="expansion-cards" class="expansion-cards">
                <div class="empty-state">Select a base device to see available expansion cards</div>
            </div>
        </div>
        
        <!-- Preview -->
        <div class="builder-section">
            <h3>Preview</h3>
            <div id="custom-midnam-preview" class="preview-section">
                <div class="empty-state">Select a base device and expansion cards to preview</div>
            </div>
        </div>
        
        <!-- Build Actions -->
        <div class="builder-section">
            <h3>Build Custom .midnam</h3>
            <div class="build-actions">
                <input type="text" id="custom-midnam-name" placeholder="Enter name for custom .midnam..." style="width: 300px; margin-right: 1rem;">
                <button class="btn btn-primary" onclick="buildCustomMidnam()" disabled>Build Custom .midnam</button>
                <button class="btn btn-secondary" onclick="previewCustomMidnam()" disabled>Preview XML</button>
            </div>
        </div>
    </div>

    <!-- File Disambiguation Dialog -->
    <div id="disambiguation-modal" class="modal-overlay" style="display: none;">
        <div class="modal-content" style="max-width: 800px;">
            <h3 id="disambiguation-title">Multiple Files Found</h3>
            <p id="disambiguation-description">Multiple .midnam files found for this device. Please select which file to use:</p>
            
            <div id="file-comparison-table" class="file-comparison">
                <table class="comparison-table">
                    <thead>
                        <tr>
                            <th>File</th>
                            <th>Size</th>
                            <th>Banks</th>
                            <th>Patches</th>
                            <th>Note Lists</th>
                            <th>Modified</th>
                            <th>Actions</th>
                        </tr>
                    </thead>
                    <tbody id="file-comparison-body">
                    </tbody>
                </table>
            </div>
            
            <div class="modal-actions">
                <button class="btn btn-secondary" onclick="closeDisambiguationModal()">Cancel</button>
            </div>
        </div>
    </div>

    <script>
        // Global state
        let selectedManufacturer = null;
        let selectedDevice = null;
        let selectedPatch = null;
        let midiManufacturers = {};
        let deviceTypes = {};
        let currentMidnam = null;
        let catalog = {}; // Store catalog globally for disambiguation

        // Global MIDI state - persistent across tabs
        let globalMIDIState = {
            access: null,
            selectedOutput: null,
            selectedOutputId: null,
            enabled: false,
            deviceName: null,
            initialized: false
        };

        // Legacy variables for compatibility
        let midiAccess = null;
        let selectedOutput = null;
        let selectedOutputId = null;
        let midiEnabled = false;
        let patchProgramChanges = {};

        // MIDI Utility Functions
        function midiNoteToName(noteNumber) {
            const noteNames = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
            const octave = Math.floor(noteNumber / 12) - 1;
            const note = noteNames[noteNumber % 12];
            return `${note}${octave}`;
        }

        function isBlackKey(noteNumber) {
            const note = noteNumber % 12;
            return [1, 3, 6, 8, 10].includes(note); // C#, D#, F#, G#, A#
        }

        // Global MIDI Functions
        function syncGlobalMIDIState() {
            // Sync legacy variables with global state
            midiAccess = globalMIDIState.access;
            selectedOutput = globalMIDIState.selectedOutput;
            selectedOutputId = globalMIDIState.selectedOutputId;
            midiEnabled = globalMIDIState.enabled;
        }

        function updateGlobalMIDIUI() {
            const midiDot = document.getElementById('midi-dot');
            const midiLabel = document.getElementById('midi-label');
            const midiDeviceInfo = document.getElementById('midi-device-info');
            const midiDeviceSelect = document.getElementById('midi-device-select');
            
            if (!midiDot || !midiLabel || !midiDeviceInfo || !midiDeviceSelect) return;
            
            // Update dot state
            if (globalMIDIState.enabled) {
                midiDot.classList.add('enabled');
                midiLabel.textContent = 'MIDI';
                midiDeviceSelect.disabled = false;
            } else {
                midiDot.classList.remove('enabled');
                midiLabel.textContent = 'MIDI';
                midiDeviceSelect.disabled = true;
            }
            
            // Update device info
            if (globalMIDIState.enabled && globalMIDIState.deviceName) {
                midiDeviceInfo.textContent = `Connected: ${globalMIDIState.deviceName}`;
                midiDeviceInfo.classList.add('connected');
            } else {
                midiDeviceInfo.textContent = 'Not connected';
                midiDeviceInfo.classList.remove('connected');
            }
        }

        function updateMIDIDeviceDropdown() {
            const select = document.getElementById('midi-device-select');
            if (!select || !globalMIDIState.enabled || !globalMIDIState.access) return;
            
            // Clear existing options and add placeholder
            select.innerHTML = '<option value="">Select a MIDI Device</option>';
            
            // Add available OUTPUT devices with stable IDs
            const outputs = Array.from(globalMIDIState.access.outputs.values());
            outputs.forEach((output) => {
                const option = document.createElement('option');
                option.value = output.id; // stable ID, not index
                option.textContent = output.name;
                select.appendChild(option);
            });
            
            // Reflect current selection by ID
            if (globalMIDIState.selectedOutputId) {
                select.value = globalMIDIState.selectedOutputId;
            }
        }

        async function toggleMIDI() {
            const midiDeviceInfo = document.getElementById('midi-device-info');
            if (!navigator.requestMIDIAccess) {
                if (midiDeviceInfo) {
                    midiDeviceInfo.textContent = 'WebMIDI not supported. Use Chrome/Edge or enable in Safari.';
                    midiDeviceInfo.classList.remove('connected');
                }
                return;
            }
            if (globalMIDIState.enabled) {
                // Disable MIDI
                globalMIDIState.enabled = false;
                globalMIDIState.selectedOutput = null;
                globalMIDIState.selectedOutputId = null;
                globalMIDIState.deviceName = null;
                syncGlobalMIDIState();
                updateGlobalMIDIUI();
                console.log('MIDI disabled');
            } else {
                // Enable MIDI on user gesture
                await initializeGlobalMIDI();
                updateMIDIDeviceDropdown();
            }
        }

        async function initializeGlobalMIDI() {
            try {
                if (!navigator.requestMIDIAccess) {
                    console.error('WebMIDI not supported in this browser');
                    return;
                }

                globalMIDIState.access = await navigator.requestMIDIAccess();
                globalMIDIState.enabled = true;
                globalMIDIState.initialized = true;
                
                // Don't auto-select devices - let user choose
                globalMIDIState.selectedOutput = null;
                globalMIDIState.selectedOutputId = null;
                globalMIDIState.deviceName = null;
                
                // Listen for device changes
                globalMIDIState.access.onstatechange = (event) => {
                    handleMIDIDeviceChange(event);
                };
                
                syncGlobalMIDIState();
                updateGlobalMIDIUI();
                updateMIDIDeviceDropdown();
                console.log('Global MIDI initialized - no device selected');
                
            } catch (error) {
                console.error('Global MIDI initialization failed:', error);
                globalMIDIState.enabled = false;
                updateGlobalMIDIUI();
            }
        }

        function selectMIDIDevice() {
            const select = document.getElementById('midi-device-select');
            if (!select || !globalMIDIState.enabled || !globalMIDIState.access) return;
            
            const selectedId = select.value;
            if (!selectedId) {
                // No device selected
                globalMIDIState.selectedOutput = null;
                globalMIDIState.selectedOutputId = null;
                globalMIDIState.deviceName = null;
            } else {
                // Device selected by stable ID
                const outputs = Array.from(globalMIDIState.access.outputs.values());
                const output = outputs.find(out => out.id === selectedId);
                if (output) {
                    globalMIDIState.selectedOutput = output;
                    globalMIDIState.selectedOutputId = output.id;
                    globalMIDIState.deviceName = output.name;
                } else {
                    // Selected device is not currently available
                    globalMIDIState.selectedOutput = null;
                    globalMIDIState.selectedOutputId = null;
                    globalMIDIState.deviceName = null;
                }
            }
            
            syncGlobalMIDIState();
            updateGlobalMIDIUI();
            updateNotePlayability(globalMIDIState.selectedOutput !== null);
            console.log('MIDI device selected:', globalMIDIState.deviceName || 'None');
        }

        function handleMIDIDeviceChange(event) {
            console.log('MIDI device change:', event.port.name, event.port.state);
            
            if (event.port.type === 'output') {
                if (event.port.state === 'disconnected' && event.port.id === globalMIDIState.selectedOutputId) {
                    // Our selected device was disconnected
                    globalMIDIState.selectedOutput = null;
                    globalMIDIState.selectedOutputId = null;
                    globalMIDIState.deviceName = null;
                }
                // Don't auto-select newly connected devices - let user choose
                
                syncGlobalMIDIState();
                updateMIDIDeviceDropdown();
                updateGlobalMIDIUI();
            }
        }

        // Prepare UI on page load (request access only on user gesture)
        document.addEventListener('DOMContentLoaded', function() {
            const midiDeviceInfo = document.getElementById('midi-device-info');
            const midiDeviceSelect = document.getElementById('midi-device-select');
            if (!navigator.requestMIDIAccess) {
                if (midiDeviceInfo) {
                    midiDeviceInfo.textContent = 'WebMIDI not supported. Use Chrome/Edge or enable in Safari.';
                    midiDeviceInfo.classList.remove('connected');
                }
                if (midiDeviceSelect) midiDeviceSelect.disabled = true;
            } else {
                if (midiDeviceInfo) {
                    midiDeviceInfo.textContent = 'Not connected';
                    midiDeviceInfo.classList.remove('connected');
                }
                if (midiDeviceSelect) midiDeviceSelect.disabled = true;
            }
            
            // Initialize note names for autocomplete
            initializeNoteNames();
        });

        // MIDI State Management Functions
        function validateMIDIState() {
            // Use global MIDI state
            if (!globalMIDIState.enabled || !globalMIDIState.access) {
                console.log('MIDI not enabled or access lost');
                return false;
            }
            
            // If we have an ID but no object, try to recover immediately
            if (globalMIDIState.selectedOutputId && !globalMIDIState.selectedOutput) {
                console.log('Selected output lost, attempting to recover...');
                recoverSelectedOutput();
                if (!globalMIDIState.selectedOutput) {
                    return false;
                }
            }
            
            return true;
        }
        
        function recoverSelectedOutput() {
            if (!globalMIDIState.access || !globalMIDIState.selectedOutputId) return;
            
            const outputs = Array.from(globalMIDIState.access.outputs.values());
            const output = outputs.find(out => out.id === globalMIDIState.selectedOutputId);
            
            if (output) {
                globalMIDIState.selectedOutput = output;
                globalMIDIState.deviceName = output.name;
                syncGlobalMIDIState();
                updateGlobalMIDIUI();
                updateNotePlayability(true);
                console.log('Recovered MIDI output:', output.name);
            } else {
                globalMIDIState.selectedOutput = null;
                globalMIDIState.selectedOutputId = null;
                globalMIDIState.deviceName = null;
                syncGlobalMIDIState();
                updateGlobalMIDIUI();
                updateNotePlayability(false);
                console.log('Could not recover MIDI output, device may have been disconnected');
            }
        }
        
        function getMIDIOutput() {
            // Validate state and recover if needed
            if (!validateMIDIState()) {
                return null;
            }
            return globalMIDIState.selectedOutput;
        }

        // Legacy WebMIDI Functions (redirected to global)
        async function initializeMIDI() {
            // Redirect to global MIDI initialization
            await initializeGlobalMIDI();
        }

        function updateMIDIDevices() {
            // Legacy function retained for compatibility but delegates to global dropdown updater
            updateMIDIDeviceDropdown();
        }

        function updateMIDIStatus(message, connected) {
            const enabledIndicator = document.getElementById('midi-enabled-indicator');
            const enabledText = document.getElementById('midi-enabled-text');
            const connectedIndicator = document.getElementById('midi-connected-indicator');
            const connectedText = document.getElementById('midi-connected-text');
            const connectBtn = document.getElementById('connect-midi-btn');
            
            if (!enabledIndicator || !enabledText || !connectedIndicator || !connectedText || !connectBtn) return;
            
            // Update MIDI enabled status
            midiEnabled = connected; // Set the global variable
            enabledIndicator.className = `midi-indicator ${connected ? 'connected' : ''}`;
            enabledText.textContent = connected ? 'MIDI' : 'MIDI';
            
            // Update device connected status
            const deviceConnected = connected && getMIDIOutput() !== null;
            connectedIndicator.className = `midi-indicator ${deviceConnected ? 'connected' : ''}`;
            connectedText.textContent = deviceConnected ? 'Connected' : 'Disconnected';
            
            // Update button text based on state
            if (connected) {
                connectBtn.textContent = 'Enabled';
                connectBtn.disabled = true;
            } else {
                connectBtn.textContent = 'Enable';
                connectBtn.disabled = false;
            }
        }

        function selectMIDIDevice() {
            // Use the global MIDI state and stable IDs
            const select = document.getElementById('midi-device-select');
            if (!select || !globalMIDIState || !globalMIDIState.enabled || !globalMIDIState.access) return;

            const selectedId = select.value;
            if (!selectedId) {
                globalMIDIState.selectedOutput = null;
                globalMIDIState.selectedOutputId = null;
                globalMIDIState.deviceName = null;
            } else {
                const outputs = Array.from(globalMIDIState.access.outputs.values());
                const output = outputs.find(out => out.id === selectedId);
                if (output) {
                    globalMIDIState.selectedOutput = output;
                    globalMIDIState.selectedOutputId = output.id;
                    globalMIDIState.deviceName = output.name;
                } else {
                    globalMIDIState.selectedOutput = null;
                    globalMIDIState.selectedOutputId = null;
                    globalMIDIState.deviceName = null;
                }
            }

            syncGlobalMIDIState();
            updateMIDIDeviceDropdown();
            updateGlobalMIDIUI();
            updateNotePlayability(globalMIDIState.selectedOutput !== null);
            console.log('MIDI device selected:', globalMIDIState.deviceName || 'None');
        }

        function updateNotePlayability(playable) {
            const noteNumbers = document.querySelectorAll('.note-number-cell');
            noteNumbers.forEach(noteDiv => {
                if (playable) {
                    noteDiv.classList.add('playable');
                } else {
                    noteDiv.classList.remove('playable');
                }
            });
        }

        function playMIDINote(noteNumber, velocity = 100, duration = 200) {
            const output = getMIDIOutput();
            if (!output) {
                alert('Please select a MIDI output device first');
                return;
            }

            try {
                // Note On
                output.send([0x90, noteNumber, velocity]);
                
                // Note Off after duration
                setTimeout(() => {
                    output.send([0x80, noteNumber, 0]);
                }, duration);
                
            } catch (error) {
                console.error('Failed to send MIDI note:', error);
                alert('Failed to send MIDI note. Check device connection.');
            }
        }

        function sendMIDIProgramChange(programNumber) {
            const output = getMIDIOutput();
            if (!output) {
                return; // Silently fail if no MIDI device selected
            }

            try {
                // Send Program Change message (0xC0 = Program Change, programNumber)
                output.send([0xC0, programNumber]);
                console.log(`Sent Program Change: ${programNumber}`);
            } catch (error) {
                console.error('Failed to send MIDI program change:', error);
            }
        }

        // Keyboard tooltip functions
        function showKeyboardTooltip(event, noteNumber) {
            const tooltip = document.getElementById('keyboard-tooltip');
            const noteName = midiNoteToName(noteNumber);
            tooltip.innerHTML = `<img src="assets/kbd.svg" alt="MIDI Keyboard" width="24" height="24"> Play ${noteName}`;
            tooltip.style.display = 'flex';
            updateTooltipPosition(event);
        }

        function hideKeyboardTooltip() {
            const tooltip = document.getElementById('keyboard-tooltip');
            tooltip.style.display = 'none';
        }

        function updateTooltipPosition(event) {
            const tooltip = document.getElementById('keyboard-tooltip');
            tooltip.style.left = (event.pageX + 10) + 'px';
            tooltip.style.top = (event.pageY - 40) + 'px';
        }

        // Catalog functions
        async function loadCatalog() {
            const statusEl = document.getElementById('catalog-status');
            const contentEl = document.getElementById('catalog-content');
            
            try {
                statusEl.textContent = 'Loading catalog...';
                contentEl.innerHTML = '<div class="loading">Loading catalog...</div>';
                
                const response = await fetch('/midnam_catalog');
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const catalog = await response.json();
                window.catalog = catalog; // Store globally for disambiguation
                displayCatalog(catalog);
                
                const totalDevices = Object.keys(catalog).length;
                const totalFiles = Object.values(catalog).reduce((sum, device) => sum + device.files.length, 0);
                statusEl.textContent = `Loaded ${totalDevices} devices with ${totalFiles} files`;
                
            } catch (error) {
                console.error('Error loading catalog:', error);
                contentEl.innerHTML = `<div class="error">Error loading catalog: ${error.message}</div>`;
                statusEl.textContent = 'Error loading catalog';
            }
        }

        function displayCatalog(catalog) {
            const contentEl = document.getElementById('catalog-content');
            
            if (Object.keys(catalog).length === 0) {
                contentEl.innerHTML = '<div class="loading">No .midnam files found in catalog</div>';
                return;
            }
            
            const sortedDevices = Object.entries(catalog).sort(([a], [b]) => a.localeCompare(b));
            
            contentEl.innerHTML = `
                <table class="catalog-table">
                    <thead>
                        <tr>
                            <th>Device Key</th>
                            <th>Manufacturer</th>
                            <th>Model</th>
                            <th>Type</th>
                            <th>Family ID</th>
                            <th>Device ID</th>
                            <th>Files</th>
                        </tr>
                    </thead>
                    <tbody>
                        ${sortedDevices.map(([key, device]) => `
                            <tr>
                                <td><span class="device-key">${key}</span></td>
                                <td>${device.manufacturer}</td>
                                <td>${device.model}</td>
                                <td><span class="device-type ${device.type || 'unknown'}">${device.type || 'unknown'}</span></td>
                                <td>${device.family_id || '-'}</td>
                                <td>${device.device_id || '-'}</td>
                                <td>
                                    <div class="file-list">
                                        ${device.files.map(file => `
                                            <div class="file-item">
                                                <span class="file-path">${file.path}</span>
                                                <span class="file-size">${(file.size / 1024).toFixed(1)} KB</span>
                                            </div>
                                        `).join('')}
                                    </div>
                                </td>
                            </tr>
                        `).join('')}
                    </tbody>
                </table>
            `;
        }

        async function clearCatalogCache() {
            try {
                // Delete the cache file by making a request to the server
                // We'll add a special endpoint for this
                const response = await fetch('/clear_cache', { method: 'POST' });
                if (response.ok) {
                    document.getElementById('catalog-status').textContent = 'Cache cleared';
                    loadCatalog(); // Reload the catalog
                } else {
                    throw new Error('Failed to clear cache');
                }
            } catch (error) {
                console.error('Error clearing cache:', error);
                document.getElementById('catalog-status').textContent = 'Error clearing cache';
            }
        }

        async function loadCatalogAndManufacturers() {
            try {
                // Load catalog first
                const catalogResponse = await fetch('/midnam_catalog');
                if (!catalogResponse.ok) {
                    throw new Error(`HTTP ${catalogResponse.status}: ${catalogResponse.statusText}`);
                }
                
                const catalog = await catalogResponse.json();
                
                // Build manufacturer list from catalog
                const manufacturers = buildManufacturerListFromCatalog(catalog);
                
                // Display manufacturers
                renderManufacturers(manufacturers);
                
                // Display catalog
                displayCatalog(catalog);
                
                // Update status
                const totalDevices = Object.keys(catalog).length;
                const totalFiles = Object.values(catalog).reduce((sum, device) => sum + device.files.length, 0);
                document.getElementById('catalog-status').textContent = `Loaded ${totalDevices} devices with ${totalFiles} files from ${manufacturers.length} manufacturers`;
                
            } catch (error) {
                console.error('Error loading catalog and manufacturers:', error);
                document.getElementById('catalog-content').innerHTML = `<div class="error">Error loading catalog: ${error.message}</div>`;
                document.getElementById('catalog-status').textContent = 'Error loading catalog';
                
                // Fallback to static manufacturer list
                loadManufacturers();
            }
        }

        function buildManufacturerListFromCatalog(catalog) {
            const manufacturerMap = new Map();
            
            // Extract unique manufacturers from catalog
            Object.values(catalog).forEach(device => {
                const catalogManufacturer = device.manufacturer;
                if (catalogManufacturer && !manufacturerMap.has(catalogManufacturer)) {
                    // Try to find full manufacturer name from static list
                    const staticManufacturer = staticManufacturers.find(m => 
                        m.name.toLowerCase().includes(catalogManufacturer.toLowerCase()) ||
                        catalogManufacturer.toLowerCase().includes(m.name.toLowerCase())
                    );
                    
                    // Use full name if found, otherwise use catalog name
                    const fullName = staticManufacturer ? staticManufacturer.name : catalogManufacturer;
                    
                    manufacturerMap.set(catalogManufacturer, {
                        name: fullName,
                        catalogName: catalogManufacturer, // Keep original for device matching
                        id: staticManufacturer ? staticManufacturer.id : '00 00 00',
                        deviceCount: 0,
                        fileCount: 0
                    });
                }
                
                // Count devices and files for this manufacturer
                if (manufacturerMap.has(catalogManufacturer)) {
                    const mfg = manufacturerMap.get(catalogManufacturer);
                    mfg.deviceCount++;
                    mfg.fileCount += device.files.length;
                }
            });
            
            // Convert to array and sort by name
            return Array.from(manufacturerMap.values()).sort((a, b) => a.name.localeCompare(b.name));
        }

        // Static manufacturer list as fallback
        const staticManufacturers = [
            {"name": "Alesis Studio Electronics", "id": "00 00 0E"},
            {"name": "Yamaha Corporation", "id": "43"},
            {"name": "Roland Corporation", "id": "41"},
            {"name": "Korg Inc", "id": "42"},
            {"name": "Kawai Musical Instruments", "id": "40"},
            {"name": "Casio Computer Co Ltd", "id": "44"},
            {"name": "Akai Electric Co Ltd", "id": "47"},
            {"name": "Sony Corporation", "id": "4C"},
            {"name": "Behringer GmbH", "id": "00 20 32"},
            {"name": "Arturia", "id": "00 20 6B"},
            {"name": "Novation", "id": "00 20 29"},
            {"name": "M-Audio", "id": "00 20 0D"},
            {"name": "E-Mu Systems", "id": "00 00 0F"},
            {"name": "Ensoniq", "id": "00 00 0F"},
            {"name": "Kurzweil", "id": "00 00 0A"},
            {"name": "Oberheim", "id": "00 00 0B"},
            {"name": "Sequential", "id": "00 00 0C"},
            {"name": "Moog", "id": "00 00 0D"},
            {"name": "Dave Smith Instruments", "id": "00 00 0D"},
            {"name": "Waldorf", "id": "00 20 0A"},
            {"name": "Access", "id": "00 20 0B"},
            {"name": "Clavia", "id": "00 20 0C"},
            {"name": "Nord", "id": "00 20 0C"},
            {"name": "Virus", "id": "00 20 0B"},
            {"name": "Propellerhead", "id": "00 20 0D"},
            {"name": "Reason", "id": "00 20 0D"}
        ];

        // Custom .midnam Builder functionality
        let selectedBaseDevice = null;
        let selectedExpansionCards = new Set();

        async function populateBaseDeviceDropdown() {
            const select = document.getElementById('base-device-select');
            if (!select) return;
            
            select.innerHTML = '<option value="">Choose a device...</option>';
            
            try {
                const catalogResponse = await fetch('/midnam_catalog');
                if (!catalogResponse.ok) return;
                
                const catalog = await catalogResponse.json();
                
                // Group devices by manufacturer
                const manufacturers = new Map();
                Object.values(catalog).forEach(device => {
                    if (!manufacturers.has(device.manufacturer)) {
                        manufacturers.set(device.manufacturer, []);
                    }
                    manufacturers.get(device.manufacturer).push(device);
                });
                
                // Add devices to dropdown
                Array.from(manufacturers.keys()).sort().forEach(manufacturer => {
                    const optgroup = document.createElement('optgroup');
                    optgroup.label = manufacturer;
                    
                    manufacturers.get(manufacturer).forEach(device => {
                        const option = document.createElement('option');
                        option.value = `${device.manufacturer}|${device.model}`;
                        option.textContent = `${device.model}`;
                        optgroup.appendChild(option);
                    });
                    
                    select.appendChild(optgroup);
                });
                
            } catch (error) {
                console.error('Error populating base device dropdown:', error);
            }
        }

        async function selectBaseDevice(deviceKey) {
            if (!deviceKey) {
                selectedBaseDevice = null;
                document.getElementById('base-device-info').style.display = 'none';
                document.getElementById('expansion-cards').innerHTML = '<div class="empty-state">Select a base device to see available expansion cards</div>';
                return;
            }
            
            try {
                const catalogResponse = await fetch('/midnam_catalog');
                if (!catalogResponse.ok) return;
                
                const catalog = await catalogResponse.json();
                const deviceInfo = catalog[deviceKey];
                
                if (!deviceInfo) return;
                
                // Check if there are multiple files for this device
                if (deviceInfo.files.length > 1) {
                    // Show disambiguation dialog
                    await showFileDisambiguationDialog(deviceKey, deviceInfo.files);
                    return;
                }
                
                selectedBaseDevice = deviceInfo;
                
                // Update device info display
                document.getElementById('base-device-name').textContent = `${deviceInfo.manufacturer} ${deviceInfo.model}`;
                document.getElementById('base-device-description').textContent = 
                    `Base device with ${deviceInfo.files.length} .midnam file(s) available.`;
                document.getElementById('base-device-info').style.display = 'block';
                
                // Find expansion cards for this device
                await loadExpansionCards(deviceInfo);
                
            } catch (error) {
                console.error('Error selecting base device:', error);
            }
        }

        async function loadExpansionCards(baseDevice) {
            const expansionCardsContainer = document.getElementById('expansion-cards');
            
            try {
                // Find expansion files for this device
                const expansionFiles = [];
                baseDevice.files.forEach(file => {
                    const fileName = file.path.split('/').pop();
                    // Check if this looks like an expansion file
                    if (fileName.toLowerCase().includes('expansion') || 
                        fileName.toLowerCase().includes('card') ||
                        fileName.toLowerCase().includes('fx')) {
                        expansionFiles.push(file);
                    }
                });
                
                if (expansionFiles.length === 0) {
                    expansionCardsContainer.innerHTML = '<div class="empty-state">No expansion cards found for this device</div>';
                    return;
                }
                
                // Display expansion cards
                expansionCardsContainer.innerHTML = expansionFiles.map(file => {
                    const fileName = file.path.split('/').pop();
                    const cardName = fileName.replace('.midnam', '').replace(/_/g, ' ');
                    return `
                        <div class="expansion-card" onclick="toggleExpansionCard('${file.path}')">
                            <input type="checkbox" id="card-${file.path.replace(/[^a-zA-Z0-9]/g, '-')}" 
                                   onchange="toggleExpansionCard('${file.path}')">
                            <h4>${cardName}</h4>
                            <p>${(file.size / 1024).toFixed(1)} KB</p>
                        </div>
                    `;
                }).join('');
                
            } catch (error) {
                console.error('Error loading expansion cards:', error);
                expansionCardsContainer.innerHTML = '<div class="empty-state">Error loading expansion cards</div>';
            }
        }

        function toggleExpansionCard(filePath) {
            if (selectedExpansionCards.has(filePath)) {
                selectedExpansionCards.delete(filePath);
            } else {
                selectedExpansionCards.add(filePath);
            }
            
            // Update visual state
            const cardElement = document.querySelector(`[onclick="toggleExpansionCard('${filePath}')"]`);
            const checkbox = cardElement.querySelector('input[type="checkbox"]');
            checkbox.checked = selectedExpansionCards.has(filePath);
            
            if (selectedExpansionCards.has(filePath)) {
                cardElement.classList.add('selected');
            } else {
                cardElement.classList.remove('selected');
            }
            
            // Update preview and build buttons
            updatePreview();
        }

        async function updatePreview() {
            const previewContainer = document.getElementById('custom-midnam-preview');
            const buildButton = document.querySelector('[onclick="buildCustomMidnam()"]');
            const previewButton = document.querySelector('[onclick="previewCustomMidnam()"]');
            
            if (!selectedBaseDevice || selectedExpansionCards.size === 0) {
                previewContainer.innerHTML = '<div class="empty-state">Select a base device and expansion cards to preview</div>';
                buildButton.disabled = true;
                previewButton.disabled = true;
                return;
            }
            
            try {
                // Create preview
                const preview = `
                    <h4>Custom .midnam Preview</h4>
                    <p><strong>Base Device:</strong> ${selectedBaseDevice.manufacturer} ${selectedBaseDevice.model}</p>
                    <p><strong>Expansion Cards:</strong> ${Array.from(selectedExpansionCards).map(path => path.split('/').pop()).join(', ')}</p>
                    <p><strong>Files to merge:</strong> ${1 + selectedExpansionCards.size} .midnam files</p>
                    <div class="preview-note">
                        <em>Note: This will create a new .midnam file combining the base device with selected expansion cards.</em>
                    </div>
                `;
                
                previewContainer.innerHTML = preview;
                buildButton.disabled = false;
                previewButton.disabled = false;
                
            } catch (error) {
                console.error('Error updating preview:', error);
                previewContainer.innerHTML = '<div class="empty-state">Error creating preview</div>';
            }
        }

        async function buildCustomMidnam() {
            const customName = document.getElementById('custom-midnam-name').value.trim();
            if (!customName) {
                alert('Please enter a name for the custom .midnam file');
                return;
            }
            
            if (!selectedBaseDevice || selectedExpansionCards.size === 0) {
                alert('Please select a base device and at least one expansion card');
                return;
            }
            
            try {
                // This would implement the actual .midnam merging logic
                alert(`Custom .midnam "${customName}" would be built here!\n\nThis feature will merge:\n- Base: ${selectedBaseDevice.manufacturer} ${selectedBaseDevice.model}\n- Expansions: ${Array.from(selectedExpansionCards).length} cards`);
                
                // TODO: Implement actual .midnam merging and saving
                
            } catch (error) {
                console.error('Error building custom .midnam:', error);
                alert('Error building custom .midnam: ' + error.message);
            }
        }

        async function previewCustomMidnam() {
            alert('XML preview feature will be implemented here');
            // TODO: Show the merged XML structure
        }

        // File Disambiguation Functions
        async function showFileDisambiguationDialog(deviceKey, files) {
            const modal = document.getElementById('disambiguation-modal');
            const title = document.getElementById('disambiguation-title');
            const description = document.getElementById('disambiguation-description');
            const tbody = document.getElementById('file-comparison-body');
            
            title.textContent = `Multiple Files Found for ${deviceKey}`;
            description.textContent = `Found ${files.length} .midnam files for this device. Please select which file to use:`;
            
            // Clear existing rows
            tbody.innerHTML = '';
            
            // Analyze each file
            const fileAnalyses = [];
            for (const file of files) {
                try {
                    const response = await fetch(`/analyze_file/${file.path}`);
                    if (response.ok) {
                        const analysis = await response.json();
                        fileAnalyses.push(analysis);
                    } else {
                        console.error(`Failed to analyze ${file.path}`);
                    }
                } catch (error) {
                    console.error(`Error analyzing ${file.path}:`, error);
                }
            }
            
            // Sort by total patches (descending) then by file size (descending)
            fileAnalyses.sort((a, b) => {
                if (a.total_patches !== b.total_patches) {
                    return b.total_patches - a.total_patches;
                }
                return b.file_size - a.file_size;
            });
            
            // Create table rows
            fileAnalyses.forEach((analysis, index) => {
                const row = document.createElement('tr');
                const fileName = analysis.file_path.split('/').pop();
                const fileSize = (analysis.file_size / 1024).toFixed(1);
                const modifiedDate = new Date(analysis.file_modified * 1000).toLocaleDateString();
                
                row.innerHTML = `
                    <td>
                        <div class="file-path">${fileName}</div>
                        <div style="font-size: 0.8rem; color: #999;">${analysis.file_path}</div>
                    </td>
                    <td class="file-size">${fileSize} KB</td>
                    <td>${analysis.total_banks}</td>
                    <td>${analysis.total_patches}</td>
                    <td>${analysis.total_note_lists}</td>
                    <td class="file-modified">${modifiedDate}</td>
                    <td>
                        <div class="action-buttons">
                            <button class="btn btn-primary btn-tiny" onclick="selectFileForBuilder('${analysis.file_path}')">Use This File</button>
                            <button class="btn btn-secondary btn-tiny" onclick="showFileDetails('${analysis.file_path}')">Details</button>
                            ${fileAnalyses.length > 1 ? `<button class="btn btn-warning btn-tiny" onclick="mergeFiles(${JSON.stringify(fileAnalyses).replace(/"/g, '&quot;')}, '${analysis.file_path}')">Merge All</button>` : ''}
                            <button class="btn btn-danger btn-tiny" onclick="deleteFile('${analysis.file_path}')">Delete</button>
                        </div>
                    </td>
                `;
                
                // Highlight the file with most patches
                if (index === 0) {
                    row.style.backgroundColor = '#e8f5e8';
                }
                
                tbody.appendChild(row);
            });
            
            modal.style.display = 'flex';
        }

        function closeDisambiguationModal() {
            document.getElementById('disambiguation-modal').style.display = 'none';
        }

        function selectFileForBuilder(filePath) {
            closeDisambiguationModal();
            
            // Find the device info for this file
            const deviceKey = Object.keys(window.catalog).find(key => {
                const deviceInfo = window.catalog[key];
                return deviceInfo.files.some(file => file.path === filePath);
            });
            
            if (deviceKey) {
                const deviceInfo = window.catalog[deviceKey];
                // Create a modified device info with only the selected file
                const singleFileDeviceInfo = {
                    ...deviceInfo,
                    files: [deviceInfo.files.find(file => file.path === filePath)]
                };
                
                selectedBaseDevice = singleFileDeviceInfo;
                
                // Update device info display
                document.getElementById('base-device-name').textContent = `${deviceInfo.manufacturer} ${deviceInfo.model}`;
                document.getElementById('base-device-description').textContent = 
                    `Base device using ${filePath.split('/').pop()}`;
                document.getElementById('base-device-info').style.display = 'block';
                
                // Find expansion cards for this device
                loadExpansionCards(singleFileDeviceInfo);
            }
        }

        function showFileDetails(filePath) {
            // Show detailed analysis of the file
            fetch(`/analyze_file/${filePath}`)
                .then(response => response.json())
                .then(analysis => {
                    const details = `
File: ${analysis.file_path}
Size: ${(analysis.file_size / 1024).toFixed(1)} KB
Manufacturer: ${analysis.manufacturer}
Model: ${analysis.model}
Total Banks: ${analysis.total_banks}
Total Patches: ${analysis.total_patches}
Total Note Lists: ${analysis.total_note_lists}

Bank Details:
${analysis.bank_details.map(bank => `  ${bank.name}: ${bank.patch_count} patches`).join('\n')}
                    `;
                    alert(details);
                })
                .catch(error => {
                    console.error('Error getting file details:', error);
                    alert('Error loading file details');
                });
        }

        async function mergeFiles(fileAnalyses, primaryFilePath) {
            if (!confirm('This will merge all files into the primary file and delete the others. Continue?')) {
                return;
            }
            
            try {
                const sourceFiles = fileAnalyses.map(analysis => analysis.file_path);
                const outputFile = primaryFilePath;
                
                const response = await fetch('/merge_files', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        source_files: sourceFiles,
                        output_file: outputFile
                    })
                });
                
                if (response.ok) {
                    const result = await response.json();
                    alert(result.message);
                    closeDisambiguationModal();
                    // Refresh the catalog
                    loadCatalog();
                } else {
                    throw new Error(`HTTP ${response.status}`);
                }
            } catch (error) {
                console.error('Error merging files:', error);
                alert('Error merging files: ' + error.message);
            }
        }

        async function deleteFile(filePath) {
            if (!confirm(`Are you sure you want to delete ${filePath}?`)) {
                return;
            }
            
            try {
                const response = await fetch('/delete_file', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        file_path: filePath
                    })
                });
                
                if (response.ok) {
                    const result = await response.json();
                    alert(result.message);
                    closeDisambiguationModal();
                    // Refresh the catalog
                    loadCatalog();
                } else {
                    throw new Error(`HTTP ${response.status}`);
                }
            } catch (error) {
                console.error('Error deleting file:', error);
                alert('Error deleting file: ' + error.message);
            }
        }

        // Initialize the application
        document.addEventListener('DOMContentLoaded', function() {
            initializeTabs();
            loadCatalogAndManufacturers(); // Load catalog first, then build manufacturer list
            populateBaseDeviceDropdown(); // Populate builder dropdown
            
            // Initialize MIDI
            initializeMIDI();
            
            // Add MIDI device select listener
            const midiDeviceSelect = document.getElementById('midi-device-select');
            if (midiDeviceSelect) {
                midiDeviceSelect.addEventListener('change', selectMIDIDevice);
            }
            
            // Set up periodic MIDI state validation
            setInterval(() => {
                if (selectedOutputId) { // Only validate if we have a selected device
                    validateMIDIState();
                }
            }, 5000); // Check every 5 seconds
        });

        // Tab management
        function initializeTabs() {
            const tabs = document.querySelectorAll('.tab');
            const tabContents = document.querySelectorAll('.tab-content');

            tabs.forEach(tab => {
                tab.addEventListener('click', () => {
                    const targetTab = tab.dataset.tab;
                    
                    // Update tab appearance
                    tabs.forEach(t => t.classList.remove('active'));
                    tab.classList.add('active');
                    
                    // Update content
                    tabContents.forEach(content => content.classList.remove('active'));
                    document.getElementById(`${targetTab}-tab`).classList.add('active');
                    
                    // Handle tab-specific initialization
                    handleTabChange(targetTab);
                });
            });
        }

        function handleTabChange(tabName) {
            // Validate MIDI state on tab change to ensure persistence
            validateMIDIState();
            
            switch(tabName) {
                case 'device':
                    if (selectedDevice) {
                        loadDeviceStructure(selectedDevice);
                    }
                    break;
                case 'patch':
                    if (selectedPatch) {
                        initializePatchEditor(selectedPatch);
                    } else {
                        // Show patch selection interface when no patch is selected
                        showPatchSelectionInterface();
                    }
                    break;
            }
        }

        function showPatchSelectionInterface() {
            const container = document.getElementById('patch-editor-container');
            
            if (!selectedDevice) {
                container.innerHTML = `
                    <div class="structure-item">
                        <h3>Patch Editor</h3>
                        <p>Please select a device from the Device tab first.</p>
                    </div>
                `;
                return;
            }
            
            if (!currentMidnam) {
                container.innerHTML = `
                    <div class="structure-item">
                        <h3>Patch Editor</h3>
                        <p>No device data loaded. Please select a device from the Device tab first.</p>
                    </div>
                `;
                return;
            }
            
            // Show available patches from the loaded XML
            const midnamDoc = currentMidnam.querySelector('MIDINameDocument');
            if (!midnamDoc) {
                container.innerHTML = `
                    <div class="structure-item">
                        <h3>Patch Editor</h3>
                        <p>No valid MIDI name document found.</p>
                    </div>
                `;
                return;
            }
            
            const patchBanks = midnamDoc.querySelectorAll('PatchBank');
            let patchListHtml = '';
            
            if (patchBanks.length === 0) {
                patchListHtml = '<p>No patch banks found in the loaded device data.</p>';
            } else {
                patchListHtml = '<h4>Available Patches:</h4><div class="patch-selection-list">';
                
                patchBanks.forEach(patchBank => {
                    const bankName = patchBank.getAttribute('Name');
                    const patches = patchBank.querySelectorAll('Patch');
                    
                    if (patches.length > 0) {
                        patchListHtml += `<div class="patch-bank-section"><h5>${bankName}</h5>`;
                        
                        patches.forEach(patch => {
                            const patchName = patch.getAttribute('Name');
                            const patchNumber = patch.getAttribute('Number');
                            const programChange = patch.getAttribute('ProgramChange') || patchNumber;
                            
                            patchListHtml += `
                                <div class="patch-selection-item" onclick="selectPatch('${bankName}', '${patchName}', '${patchNumber}', '${programChange}')">
                                    <span class="patch-number">#${patchNumber}</span>
                                    <span class="patch-name">${patchName}</span>
                                    <span class="patch-program-change">PC: <button class="patch-program-change-btn" onclick="sendMIDIProgramChange(${programChange})" title="Send Program Change ${programChange}">${programChange}</button></span>
                                </div>
                            `;
                        });
                        
                        patchListHtml += '</div>';
                    }
                });
                
                patchListHtml += '</div>';
            }
            
            container.innerHTML = `
                <div class="structure-item">
                    <h3>Patch Editor</h3>
                    <p>Select a patch to edit:</p>
                    ${patchListHtml}
                </div>
            `;
        }

        // Load manufacturers from the server
        async function loadManufacturers() {
            const loading = document.getElementById('manufacturer-loading');
            const grid = document.getElementById('manufacturer-grid');
            
            try {
                const response = await fetch('/manufacturers');
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const manufacturers = await response.json();
                loading.style.display = 'none';
                renderManufacturers(manufacturers);
                
            } catch (error) {
                loading.innerHTML = `<div class="error">Error loading manufacturers: ${error.message}</div>`;
            }
        }

        function renderManufacturers(manufacturers) {
            const input = document.getElementById('manufacturer-input');
            const dropdown = document.getElementById('manufacturer-dropdown-list');
            
            // Store manufacturers globally for filtering
            window.allManufacturers = manufacturers;
            
            // Add input event listener for filtering
            input.addEventListener('input', (e) => {
                const searchTerm = e.target.value.toLowerCase();
                const filtered = manufacturers.filter(m => 
                    m.name.toLowerCase().includes(searchTerm)
                );
                showDropdown(filtered);
            });
            
            // Add focus event to show all manufacturers
            input.addEventListener('focus', () => {
                showDropdown(manufacturers);
            });
            
            // Add click outside to hide dropdown
            document.addEventListener('click', (e) => {
                if (!input.contains(e.target) && !dropdown.contains(e.target)) {
                    hideDropdown();
                }
            });
        }

        function showDropdown(manufacturers) {
            const dropdown = document.getElementById('manufacturer-dropdown-list');
            dropdown.innerHTML = '';
            
            manufacturers.forEach(manufacturer => {
                const option = document.createElement('div');
                option.className = 'manufacturer-option';
                
                // Create content with device and file counts
                const content = document.createElement('div');
                content.innerHTML = `
                    <div class="manufacturer-name">${manufacturer.name}</div>
                    <div class="manufacturer-stats">${manufacturer.deviceCount} devices, ${manufacturer.fileCount} files</div>
                `;
                
                option.appendChild(content);
                option.dataset.manufacturer = manufacturer.name;
                option.dataset.id = manufacturer.id;
                
                option.addEventListener('click', () => {
                    selectManufacturer(manufacturer);
                    hideDropdown();
                });
                
                dropdown.appendChild(option);
            });
            
            dropdown.classList.add('show');
        }

        function hideDropdown() {
            const dropdown = document.getElementById('manufacturer-dropdown-list');
            dropdown.classList.remove('show');
        }

        function selectManufacturer(manufacturer) {
            selectedManufacturer = manufacturer;
            
            // Update input field
            document.getElementById('manufacturer-input').value = manufacturer.name;
            
            // Show manufacturer details
            const details = document.getElementById('manufacturer-details');
            details.classList.add('show');
            
            // Update manufacturer info
            document.getElementById('manufacturer-id').textContent = manufacturer.id;
            
            // Load and display devices
            loadDevicesForManufacturer(manufacturer);
            
            // Update device tab info
            document.getElementById('selected-manufacturer').textContent = manufacturer.name;
        }

        // Load devices for selected manufacturer
        async function loadDevicesForManufacturer(manufacturer) {
            const deviceTableBody = document.getElementById('device-table-body');
            const deviceCount = document.getElementById('device-count');
            
            // Clear existing devices
            deviceTableBody.innerHTML = '';
            deviceCount.textContent = 'Loading...';

            try {
                // Load devices from catalog instead of .middev files
                const catalogResponse = await fetch('/midnam_catalog');
                if (!catalogResponse.ok) {
                    throw new Error(`Failed to load catalog: ${catalogResponse.status}`);
                }
                
                const catalog = await catalogResponse.json();
                
                // Find devices for this manufacturer using catalog name
                const catalogName = manufacturer.catalogName || convertToCatalogName(manufacturer.name);
                const devices = [];
                
                Object.values(catalog).forEach(device => {
                    if (device.manufacturer === catalogName) {
                        devices.push({
                            name: device.model,
                            manufacturer: device.manufacturer,
                            isDrumMachine: false, // Default values since catalog doesn't have this info
                            isSampler: false,
                            isEffectUnit: false,
                            isMixer: false,
                            supportsGeneralMIDI: false,
                            supportsMMC: false,
                            familyId: device.family_id,
                            deviceId: device.device_id,
                            files: device.files
                        });
                    }
                });
                
                // Sort devices alphabetically by name
                devices.sort((a, b) => a.name.localeCompare(b.name));
                
                deviceCount.textContent = devices.length;
                renderDevicesTable(devices);
                
            } catch (error) {
                deviceCount.textContent = 'Error';
                deviceTableBody.innerHTML = `
                    <tr>
                        <td colspan="3" style="text-align: center; color: #dc3545; padding: 2rem;">
                            Error loading devices: ${error.message}
                        </td>
                    </tr>
                `;
            }
        }

        function renderDevicesTable(devices) {
            const deviceTableBody = document.getElementById('device-table-body');
            deviceTableBody.innerHTML = '';

            devices.forEach(device => {
                const row = document.createElement('tr');
                row.dataset.device = device.name;
                
                // Determine primary device type
                let primaryType = 'MIDI Device';
                if (device.isDrumMachine) primaryType = 'Drum Machine';
                else if (device.isSampler) primaryType = 'Sampler';
                else if (device.isEffectUnit) primaryType = 'Effect Unit';
                else if (device.isMixer) primaryType = 'Mixer';
                
                // Build capability tags
                const capabilities = [];
                if (device.supportsGeneralMIDI) capabilities.push('General MIDI');
                if (device.supportsMMC) capabilities.push('MMC');
                if (device.isDrumMachine) capabilities.push('Drum Machine');
                if (device.isSampler) capabilities.push('Sampler');
                if (device.isEffectUnit) capabilities.push('Effect Unit');
                if (device.isMixer) capabilities.push('Mixer');
                
                const capabilityTags = capabilities.map(cap => 
                    `<span class="capability-tag active">${cap}</span>`
                ).join('');
                
                row.innerHTML = `
                    <td>
                        <div class="device-name">${device.name}</div>
                    </td>
                    <td>
                        <div class="device-type">${primaryType}</div>
                    </td>
                    <td>
                        <div class="device-capabilities">${capabilityTags || '<span class="capability-tag">Basic MIDI</span>'}</div>
                    </td>
                `;
                
                row.addEventListener('click', () => selectDevice(device));
                deviceTableBody.appendChild(row);
            });
        }


        function selectDevice(device) {
            selectedDevice = device;
            
            // Debug: Log the device structure
            console.log('Device selected:', device);
            console.log('Device files:', device.files);
            
            // Update UI - remove previous selections
            document.querySelectorAll('.device-table tr').forEach(row => {
                row.classList.remove('selected');
            });
            
            // Add selection to current row
            const selectedRow = document.querySelector(`[data-device="${device.name}"]`);
            if (selectedRow) {
                selectedRow.classList.add('selected');
            }
            
            // Update device tab info
            document.getElementById('selected-device').textContent = `${device.manufacturer} ${device.name}`;
            
            // Try to load existing .midnam file for this device
            loadDeviceMidnam(device);
            
            // Switch to device tab
            document.querySelector('[data-tab="device"]').click();
        }

        async function loadDeviceMidnam(device) {
            try {
                // First, get the catalog of all .midnam files
                const catalogResponse = await fetch('/midnam_catalog');
                if (!catalogResponse.ok) {
                    console.error('Failed to fetch midnam catalog');
                    return;
                }
                
                const catalog = await catalogResponse.json();
                
                // Find matching devices in the catalog
                // Convert full manufacturer name to catalog name for matching
                const catalogManufacturer = convertToCatalogName(device.manufacturer);
                const deviceKey = `${catalogManufacturer}|${device.name}`;
                const matchingDevices = [];
                
                // Look for exact matches first
                if (catalog[deviceKey]) {
                    const deviceInfo = catalog[deviceKey];
                    // Check if this device has multiple files
                    if (deviceInfo.files && deviceInfo.files.length > 1) {
                        // Multiple files for same device - show selection dialog
                        const selectedFile = await showFileSelectionDialog(deviceInfo.files, device);
                        if (!selectedFile) return;
                        await loadSpecificMidnamFile({ files: [selectedFile] });
                    } else {
                        // Single file or no files - load directly
                        matchingDevices.push({
                            key: deviceKey,
                            info: deviceInfo,
                            matchType: 'exact'
                        });
                    }
                }
                
                // Look for partial matches (same manufacturer, similar model name)
                for (const [key, info] of Object.entries(catalog)) {
                    if (key !== deviceKey && 
                        info.manufacturer.toLowerCase() === catalogManufacturer.toLowerCase()) {
                        // Check if model names are similar
                        const deviceModel = device.name.toLowerCase();
                        const catalogModel = info.model.toLowerCase();
                        
                        if (deviceModel.includes(catalogModel) || catalogModel.includes(deviceModel)) {
                            matchingDevices.push({
                                key: key,
                                info: info,
                                matchType: 'partial'
                            });
                        }
                    }
                }
                
                if (matchingDevices.length === 0) {
                    console.log(`No .midnam files found for ${device.manufacturer} ${device.name}`);
                    return;
                }
                
                // If multiple matches, show selection dialog
                if (matchingDevices.length > 1) {
                    const selectedDevice = await showDeviceSelectionDialog(matchingDevices, device);
                    if (!selectedDevice) return;
                    await loadSpecificMidnamFile(selectedDevice.info);
                } else {
                    // Single match, load it directly
                    await loadSpecificMidnamFile(matchingDevices[0].info);
                }
                
            } catch (error) {
                console.error(`Error loading .midnam for ${device.manufacturer} ${device.name}:`, error);
            }
        }

        async function showDeviceSelectionDialog(matchingDevices, originalDevice) {
            return new Promise((resolve) => {
                // Create modal dialog
                const modal = document.createElement('div');
                modal.className = 'modal-overlay';
                modal.innerHTML = `
                    <div class="modal-content">
                        <h3>Multiple .midnam files found for ${originalDevice.manufacturer} ${originalDevice.name}</h3>
                        <p>Select which file to load:</p>
                        <div class="device-selection-list">
                            ${matchingDevices.map((match, index) => `
                                <div class="device-selection-item" data-index="${index}">
                                    <div class="device-selection-header">
                                        <strong>${match.info.manufacturer} ${match.info.model}</strong>
                                        <span class="match-type">${match.matchType}</span>
                                    </div>
                                    <div class="device-selection-files">
                                        ${match.info.files.map(file => `
                                            <div class="file-info">
                                                <span class="file-path">${file.path}</span>
                                                <span class="file-size">${(file.size / 1024).toFixed(1)} KB</span>
                                            </div>
                                        `).join('')}
                                    </div>
                                </div>
                            `).join('')}
                        </div>
                        <div class="modal-actions">
                            <button class="btn btn-secondary" onclick="this.closest('.modal-overlay').remove(); resolve(null);">Cancel</button>
                        </div>
                    </div>
                `;
                
                // Add click handlers
                modal.querySelectorAll('.device-selection-item').forEach((item, index) => {
                    item.addEventListener('click', () => {
                        modal.remove();
                        resolve(matchingDevices[index]);
                    });
                });
                
                document.body.appendChild(modal);
            });
        }

        async function showFileSelectionDialog(files, originalDevice) {
            return new Promise(async (resolve) => {
                // Analyze each file first
                const fileAnalyses = [];
                for (const file of files) {
                    try {
                        const response = await fetch(`/analyze_file/${file.path}`);
                        if (response.ok) {
                            const analysis = await response.json();
                            fileAnalyses.push(analysis);
                        } else {
                            // If analysis fails, create a basic analysis object
                            fileAnalyses.push({
                                file_path: file.path,
                                file_size: file.size,
                                author: "Unknown",
                                total_banks: 0,
                                total_patches: 0,
                                total_note_lists: 0
                            });
                        }
                    } catch (error) {
                        console.error(`Error analyzing ${file.path}:`, error);
                        // Create a basic analysis object on error
                        fileAnalyses.push({
                            file_path: file.path,
                            file_size: file.size,
                            author: "Unknown",
                            total_banks: 0,
                            total_patches: 0,
                            total_note_lists: 0
                        });
                    }
                }
                
                // Create modal dialog
                const modal = document.createElement('div');
                modal.className = 'modal-overlay';
                modal.innerHTML = `
                    <div class="modal-content">
                        <h3>Multiple .midnam files found for ${originalDevice.manufacturer} ${originalDevice.name}</h3>
                        <p>Please select which file to load:</p>
                        <div class="file-selection-list">
                            ${fileAnalyses.map((analysis, index) => `
                                <div class="file-selection-item" data-index="${index}">
                                    <div class="file-selection-header">
                                        <strong>${analysis.file_path.split('/').pop()}</strong>
                                        <span class="file-size">${(analysis.file_size / 1024).toFixed(1)} KB</span>
                                    </div>
                                    <div class="file-path">${analysis.file_path}</div>
                                    <div class="file-author">Author: ${analysis.author}</div>
                                    <div class="file-node-counts">
                                        <span><span class="count-label">Banks:</span> ${analysis.total_banks}</span>
                                        <span><span class="count-label">Patches:</span> ${analysis.total_patches}</span>
                                        <span><span class="count-label">Note Lists:</span> ${analysis.total_note_lists}</span>
                                    </div>
                                </div>
                            `).join('')}
                        </div>
                        <div class="modal-actions">
                            <button class="btn btn-secondary" onclick="this.closest('.modal-overlay').remove(); resolve(null);">Cancel</button>
                        </div>
                    </div>
                `;
                
                // Add click handlers
                modal.querySelectorAll('.file-selection-item').forEach((item, index) => {
                    item.addEventListener('click', () => {
                        modal.remove();
                        resolve(files[index]);
                    });
                });
                
                document.body.appendChild(modal);
            });
        }

        async function loadSpecificMidnamFile(deviceInfo) {
            try {
                // Load the first file (or we could let user choose which file)
                const fileToLoad = deviceInfo.files[0];
                const response = await fetch(`/${fileToLoad.path}`);
                
                if (!response.ok) {
                    console.error(`Failed to load ${fileToLoad.path}`);
                    return;
                }
                
                const xmlText = await response.text();
                const parser = new DOMParser();
                const xmlDoc = parser.parseFromString(xmlText, 'text/xml');
                
                // Check for parsing errors
                const parseError = xmlDoc.querySelector('parsererror');
                if (parseError) {
                    console.error('XML Parse Error:', parseError.textContent);
                    return;
                }
                
                // Parse the MIDI Name Document
                parseMidnamDocument(xmlDoc);
                
                // Store the file path in selectedDevice for saving
                if (selectedDevice) {
                    selectedDevice.files = deviceInfo.files;
                    selectedDevice.currentFile = fileToLoad;
                    console.log('Updated selectedDevice with file info:', selectedDevice);
                }
                
                console.log(`Loaded .midnam file: ${fileToLoad.path}`);
                
            } catch (error) {
                console.error('Error loading specific .midnam file:', error);
            }
        }

        // Load device structure
        function loadDeviceStructure(device) {
            const structureEditor = document.getElementById('structure-editor');
            
            // Create a comprehensive structure editor
            structureEditor.innerHTML = `
                <div class="structure-item">
                    <h3>Device Information</h3>
                    <div class="device-info-grid">
                        <div class="info-item">
                            <div class="info-label">Manufacturer</div>
                            <div class="info-value">${device.manufacturer}</div>
                        </div>
                        <div class="info-item">
                            <div class="info-label">Model</div>
                            <div class="info-value">${device.name}</div>
                        </div>
                        <div class="info-item">
                            <div class="info-label">Type</div>
                            <div class="info-value">${getDeviceType(device)}</div>
                        </div>
                        <div class="info-item">
                            <div class="info-label">Capabilities</div>
                            <div class="info-value">${getDeviceCapabilities(device)}</div>
                        </div>
                    </div>
                </div>
                
                <div class="structure-item">
                    <h3>MIDI Name Document Structure</h3>
                    <div id="midnam-structure">
                        <div class="structure-section">
                            <h4>Channel Name Sets</h4>
                            <div id="channel-name-sets">
                                <div class="empty-state">No channel name sets defined</div>
                            </div>
                            <button class="btn btn-primary btn-small" onclick="addChannelNameSet()">Add Channel Name Set</button>
                        </div>
                        
                        <div class="structure-section">
                            <h4>Patch Banks</h4>
                            <div id="patch-banks">
                                <div class="empty-state">No patch banks defined</div>
                            </div>
                            <button class="btn btn-primary btn-small" onclick="addPatchBank()">Add Patch Bank</button>
                        </div>
                    </div>
                </div>
            `;
            
            // If we have loaded XML data, populate the structure
            if (currentMidnam) {
                populateDeviceStructureFromXML();
            }
        }

        function populateDeviceStructureFromXML() {
            if (!currentMidnam) return;
            
            const midnamDoc = currentMidnam.querySelector('MIDINameDocument');
            if (!midnamDoc) return;
            
            // Populate Channel Name Sets
            const channelNameSets = midnamDoc.querySelectorAll('ChannelNameSet');
            channelNameSets.forEach(channelSet => {
                const setName = channelSet.getAttribute('Name');
                if (setName) {
                    addChannelNameSetFromXML(setName, channelSet);
                }
            });
            
            // Populate Patch Banks
            const patchBanks = midnamDoc.querySelectorAll('PatchBank');
            patchBanks.forEach(patchBank => {
                const bankName = patchBank.getAttribute('Name');
                if (bankName) {
                    addPatchBankFromXML(bankName, patchBank);
                }
            });
        }

        function getDeviceType(device) {
            if (device.isDrumMachine) return 'Drum Machine';
            if (device.isSampler) return 'Sampler';
            if (device.isEffectUnit) return 'Effect Unit';
            if (device.isMixer) return 'Mixer';
            return 'MIDI Device';
        }

        function getDeviceCapabilities(device) {
            const caps = [];
            if (device.supportsGeneralMIDI) caps.push('General MIDI');
            if (device.supportsMMC) caps.push('MMC');
            if (device.isDrumMachine) caps.push('Drum Machine');
            if (device.isSampler) caps.push('Sampler');
            if (device.isEffectUnit) caps.push('Effect Unit');
            if (device.isMixer) caps.push('Mixer');
            return caps.join(', ') || 'Basic MIDI';
        }

        // Structure management functions
        function addChannelNameSet() {
            const container = document.getElementById('channel-name-sets');
            const emptyState = container.querySelector('.empty-state');
            if (emptyState) emptyState.remove();
            
            const setName = prompt('Enter Channel Name Set name:', 'Name Set 1');
            if (!setName) return;
            
            const nameSetDiv = document.createElement('div');
            nameSetDiv.className = 'structure-element';
            nameSetDiv.innerHTML = `
                <div class="element-header">
                    <span class="element-name">${setName}</span>
                    <div class="element-actions">
                        <button class="btn btn-small btn-secondary" onclick="editChannelNameSet('${setName}')">Edit</button>
                        <button class="btn btn-small btn-danger" onclick="removeChannelNameSet(this)">Remove</button>
                    </div>
                </div>
                <div class="element-content">
                    <p>Channel assignments and patch banks will be configured here.</p>
                </div>
            `;
            
            container.appendChild(nameSetDiv);
        }

        function addPatchBank() {
            const container = document.getElementById('patch-banks');
            const emptyState = container.querySelector('.empty-state');
            if (emptyState) emptyState.remove();
            
            const bankName = prompt('Enter Patch Bank name:', 'Bank 1');
            if (!bankName) return;
            
            const bankDiv = document.createElement('div');
            bankDiv.className = 'structure-element';
            
            // Get bank select information for manually created bank
            const bankIndex = Array.from(container.children).length; // Use position as bank index
            const bankSelectInfo = getBankSelectInfo(null, bankIndex); // No XML element for manual banks
            
            // Generate bank select display
            let bankSelectHtml = '';
            if (bankSelectInfo.commands.length > 0) {
                const commandsHtml = bankSelectInfo.commands.map(cmd => 
                    `<span class="bank-select-command">CC#${cmd.control}=${cmd.value}</span>`
                ).join('');
                
                bankSelectHtml = `
                    <div class="bank-select-info">
                        <div class="bank-select-status">Bank Select: ${bankSelectInfo.displayText}</div>
                        <div class="bank-select-commands">
                            ${commandsHtml}
                            <button class="bank-select-btn" onclick="sendBankSelectCommands(${JSON.stringify(bankSelectInfo.commands).replace(/"/g, '&quot;')})" title="Send bank select commands">Send</button>
                        </div>
                    </div>
                `;
            } else {
                bankSelectHtml = `
                    <div class="bank-select-info">
                        <div class="bank-select-status">${bankSelectInfo.displayText}</div>
                    </div>
                `;
            }
            
            bankDiv.innerHTML = `
                <div class="element-header">
                    <span class="element-name">${bankName}</span>
                    <div class="element-actions">
                        <button class="btn btn-small btn-secondary" onclick="editPatchBank('${bankName}')">Edit</button>
                        <button class="btn btn-small btn-danger" onclick="removePatchBank(this)">Remove</button>
                    </div>
                </div>
                <div class="bank-select-summary">
                    ${bankSelectInfo.commands.length > 0 ? 
                        `<span class="bank-select-preview">Bank Select: ${bankSelectInfo.displayText}</span>
                         <button class="bank-select-btn btn-small" onclick="sendBankSelectCommands(${JSON.stringify(bankSelectInfo.commands).replace(/"/g, '&quot;')})" title="Send bank select commands">Send</button>` :
                        `<span class="bank-select-preview">${bankSelectInfo.displayText}</span>`
                    }
                </div>
                <div class="element-content">
                    <p>Patch definitions will be configured here.</p>
                    ${bankSelectHtml}
                </div>
            `;
            
            container.appendChild(bankDiv);
        }

        // Note: addNoteNameList function removed since Note Name Lists are now managed within patches
        // instead of as separate sections in the Device tab

        function removeChannelNameSet(button) {
            if (confirm('Remove this Channel Name Set?')) {
                button.closest('.structure-element').remove();
            }
        }

        function removePatchBank(button) {
            if (confirm('Remove this Patch Bank?')) {
                button.closest('.structure-element').remove();
            }
        }

        // Note: removeNoteNameList function removed since Note Name Lists are now managed within patches

        function editChannelNameSet(name) {
            alert(`Edit Channel Name Set "${name}" - Not yet implemented`);
        }

        function togglePatchBank(name) {
            const bankElement = document.querySelector(`[onclick="togglePatchBank('${name}')"]`).closest('.structure-element');
            const content = bankElement.querySelector('.element-content');
            const expandIcon = bankElement.querySelector('.expand-icon');
            
            if (content.style.display === 'none') {
                // Expand
                content.style.display = 'block';
                expandIcon.textContent = '';
                
                // Check if we need to load patches
                if (!content.querySelector('.patch-editor')) {
                    content.innerHTML = `
                        <div class="patch-editor">
                            <div class="patch-controls">
                                <button class="btn btn-primary btn-small" onclick="addPatch('${name}')">Add Patch</button>
                                <button class="btn btn-secondary btn-small" onclick="importPatches('${name}')">Import Patches</button>
                            </div>
                            
                            <div class="patch-list" id="patch-list-${name.replace(/\s+/g, '-')}">
                                <div class="empty-state">No patches defined</div>
                            </div>
                        </div>
                    `;
                    
                    // Check if we have stored patch data and load it automatically
                    const patchBankData = bankElement.dataset.patchBankData;
                    if (patchBankData) {
                        try {
                            const data = JSON.parse(patchBankData);
                            loadPatchesFromStoredData(name, data.patches);
                        } catch (error) {
                            console.error('Error loading stored patch data:', error);
                        }
                    }
                }
            } else {
                // Collapse
                content.style.display = 'none';
                expandIcon.textContent = '';
            }
        }

        function editPatchBankSettings(name) {
            // Edit the patch bank's attributes/values (name, etc.)
            const newName = prompt('Enter new patch bank name:', name);
            if (!newName || newName === name) return;
            
            // Update the display
            const bankElement = document.querySelector(`[onclick="togglePatchBank('${name}')"]`).closest('.structure-element');
            const nameElement = bankElement.querySelector('.element-name');
            nameElement.innerHTML = `<span class="expand-icon"></span> ${newName}`;
            nameElement.setAttribute('onclick', `togglePatchBank('${newName}')`);
            
            // Update the Edit button
            const editButton = bankElement.querySelector('[onclick*="editPatchBankSettings"]');
            editButton.setAttribute('onclick', `editPatchBankSettings('${newName}')`);
            
            alert(`Patch bank renamed from "${name}" to "${newName}"`);
        }

        function loadPatchesFromStoredData(bankName, patches) {
            const listId = `patch-list-${bankName.replace(/\s+/g, '-')}`;
            const container = document.getElementById(listId);
            
            if (!container) {
                console.error(`Container ${listId} not found`);
                return;
            }
            
            // Clear empty state
            const emptyState = container.querySelector('.empty-state');
            if (emptyState) emptyState.remove();
            
            // Add each patch
            patches.forEach(patch => {
                if (patch.name && patch.number !== null) {
                    // Store program change number for MIDI switching
                    if (patch.programChange !== undefined && patch.programChange !== null) {
                        patchProgramChanges[patch.name] = parseInt(patch.programChange);
                    } else {
                        patchProgramChanges[patch.name] = parseInt(patch.number);
                    }
                    
                    const patchDiv = document.createElement('div');
                    patchDiv.className = 'patch-item';
                    patchDiv.dataset.patchName = patch.name;
                    patchDiv.dataset.bankName = bankName;
                    patchDiv.innerHTML = `
                        <div class="patch-header">
                            <div class="patch-info-inline">
                                <span class="patch-number">#${patch.number}</span>
                                <span class="patch-name">${patch.name}</span>
                                <span class="patch-program-change">PC: <button class="patch-program-change-btn" onclick="sendMIDIProgramChange(${patch.programChange || patch.number})" title="Send Program Change ${patch.programChange || patch.number}">${patch.programChange || patch.number}</button></span>
                            </div>
                            <div class="patch-actions">
                                <button class="btn btn-small btn-primary" onclick="selectPatch('${bankName}', '${patch.name}', '${patch.number}', '${patch.programChange || patch.number}')">Edit Patch</button>
                                <button class="btn btn-small btn-secondary" onclick="editPatch('${bankName}', '${patch.name}', '${patch.number}', '${patch.programChange || patch.number}')">Settings</button>
                                <button class="btn btn-small btn-secondary" onclick="${patch.usesNoteList ? `editNoteNameList('${patch.usesNoteList}', '${bankName}', '${patch.name}', '${patch.number}', '${patch.programChange || patch.number}')` : `addNoteListToPatch('${bankName}', '${patch.name}')`}">${patch.usesNoteList ? 'Edit Note Names' : 'Add Note Names'}</button>
                                <button class="btn btn-small btn-danger" onclick="removePatch(this)">Remove</button>
                            </div>
                        </div>
                        <div class="patch-details">
                        </div>
                    `;
                    
                    container.appendChild(patchDiv);
                }
            });
        }

        function addPatch(bankName) {
            const patchName = prompt('Enter patch name:', 'Patch 1');
            if (!patchName) return;
            
            const patchNumber = prompt('Enter patch number (0-127):', '0');
            if (patchNumber === null) return;
            
            const programChange = prompt('Enter program change number (0-127):', patchNumber);
            if (programChange === null) return;
            
            const listId = `patch-list-${bankName.replace(/\s+/g, '-')}`;
            const container = document.getElementById(listId);
            const emptyState = container.querySelector('.empty-state');
            if (emptyState) emptyState.remove();
            
            const patchDiv = document.createElement('div');
            patchDiv.className = 'patch-item';
            patchDiv.dataset.patchName = patchName;
            patchDiv.dataset.bankName = bankName;
            patchDiv.innerHTML = `
                <div class="patch-header">
                    <div class="patch-info-inline">
                        <span class="patch-number">#${patchNumber}</span>
                        <span class="patch-name">${patchName}</span>
                        <span class="patch-program-change">PC: <button class="patch-program-change-btn" onclick="sendMIDIProgramChange(${programChange})" title="Send Program Change ${programChange}">${programChange}</button></span>
                    </div>
                    <div class="patch-actions">
                        <button class="btn btn-small btn-primary" onclick="selectPatch('${bankName}', '${patchName}', ${patchNumber}, ${programChange})">Edit Patch</button>
                        <button class="btn btn-small btn-secondary" onclick="editPatch('${bankName}', '${patchName}', ${patchNumber}, ${programChange})">Settings</button>
                        <button class="btn btn-small btn-secondary" onclick="addNoteListToPatch('${bankName}', '${patchName}')">Add Note Names</button>
                        <button class="btn btn-small btn-danger" onclick="removePatch(this)">Remove</button>
                    </div>
                </div>
                <div class="patch-details">
                </div>
            `;
            
            container.appendChild(patchDiv);
        }

        function editPatch(bankName, patchName, patchNumber, programChange) {
            const newName = prompt('Enter new patch name:', patchName);
            if (!newName) return;
            
            const newNumber = prompt('Enter new patch number (0-127):', patchNumber);
            if (newNumber === null) return;
            
            const newProgramChange = prompt('Enter new program change number (0-127):', programChange);
            if (newProgramChange === null) return;
            
            // Update the patch element
            const patchElement = document.querySelector(`[onclick="editPatch('${bankName}', '${patchName}', ${patchNumber}, ${programChange})"]`).closest('.patch-item');
            patchElement.querySelector('.patch-name').textContent = newName;
            patchElement.querySelector('.patch-number').textContent = `#${newNumber}`;
            
            // Update the program change button
            const programChangeBtn = patchElement.querySelector('.patch-program-change-btn');
            if (programChangeBtn) {
                programChangeBtn.textContent = newProgramChange;
                programChangeBtn.setAttribute('onclick', `sendMIDIProgramChange(${newProgramChange})`);
                programChangeBtn.setAttribute('title', `Send Program Change ${newProgramChange}`);
            }
            
            // Update onclick handlers
            const editBtn = patchElement.querySelector('[onclick*="editPatch"]');
            const noteListBtn = patchElement.querySelector('[onclick*="addNoteListToPatch"]');
            
            editBtn.setAttribute('onclick', `editPatch('${bankName}', '${newName}', ${newNumber}, ${newProgramChange})`);
            noteListBtn.setAttribute('onclick', `addNoteListToPatch('${bankName}', '${newName}')`);
        }

        function addNoteListToPatch(bankName, patchName) {
            const noteListName = prompt('Enter note name list name:', `${patchName} Notes`);
            if (!noteListName) return;
            
            // Find the patch element more reliably
            const patchElement = document.querySelector(`[onclick="addNoteListToPatch('${bankName}', '${patchName}')"]`)?.closest('.patch-item');
            if (!patchElement) {
                console.error('Could not find patch element for', bankName, patchName);
                alert('Error: Could not find the patch element. Please try again.');
                return;
            }
            
            // Find or create the note lists container
            let noteListsContainer = patchElement.querySelector('.patch-note-lists');
            if (!noteListsContainer) {
                // Create the note lists container if it doesn't exist
                const patchDetails = patchElement.querySelector('.patch-details');
                if (!patchDetails) {
                    console.error('Could not find patch details container');
                    alert('Error: Could not find the patch details container. Please try again.');
                    return;
                }
                
                noteListsContainer = document.createElement('div');
                noteListsContainer.className = 'patch-note-lists';
                noteListsContainer.innerHTML = '<div class="empty-state">No note name lists assigned to this patch</div>';
                patchDetails.appendChild(noteListsContainer);
            }
            
            const emptyState = noteListsContainer.querySelector('.empty-state');
            if (emptyState) emptyState.remove();
            
            const noteListDiv = document.createElement('div');
            noteListDiv.className = 'note-list-item';
            noteListDiv.innerHTML = `
                <span class="note-list-name">${noteListName}</span>
                <div class="note-list-actions">
                    <button class="btn btn-small btn-primary" onclick="editNoteListInPatch('${bankName}', '${patchName}', '${noteListName}')">Edit</button>
                    <button class="btn btn-small btn-danger" onclick="removeNoteListFromPatch(this)">Remove</button>
                </div>
            `;
            
            noteListsContainer.appendChild(noteListDiv);
        }

        function selectPatch(bankName, patchName, patchNumber, programChange) {
            selectedPatch = {
                bankName: bankName,
                name: patchName,
                number: patchNumber,
                programChange: programChange
            };
            
            // Update patch tab info
            document.getElementById('selected-patch').textContent = `${patchName} (#${patchNumber})`;
            
            // Switch to patch tab
            document.querySelector('[data-tab="patch"]').click();
        }

        function editNoteListInPatch(bankName, patchName, noteListName) {
            // Switch to Patch tab and edit the note list
            document.querySelector('[data-tab="patch"]').click();
            alert(`Edit Note List "${noteListName}" for patch "${patchName}" - Switch to Patch tab`);
        }

        function removePatch(button) {
            if (confirm('Remove this patch?')) {
                button.closest('.patch-item').remove();
            }
        }

        function removeNoteListFromPatch(button) {
            if (confirm('Remove this note list from the patch?')) {
                button.closest('.note-list-item').remove();
            }
        }

        function importPatches(bankName) {
            // Load patches from the current XML file
            loadPatchesFromCurrentXML(bankName);
        }

        async function loadPatchesFromCurrentXML(bankName) {
            try {
                // Get the current XML document that was loaded
                if (!currentMidnam) {
                    alert('No MIDI file loaded. Please select a device first.');
                    return;
                }
                
                // Find the patch bank
                const patchBank = currentMidnam.querySelector(`PatchBank[Name="${bankName}"]`);
                if (!patchBank) {
                    alert(`Patch bank "${bankName}" not found in loaded file.`);
                    return;
                }
                
                // Get all patches in the bank
                const patches = patchBank.querySelectorAll('Patch');
                const listId = `patch-list-${bankName.replace(/\s+/g, '-')}`;
                const container = document.getElementById(listId);
                
                if (!container) {
                    alert(`Container ${listId} not found. Please expand the patch bank first.`);
                    return;
                }
                
                // Clear empty state
                const emptyState = container.querySelector('.empty-state');
                if (emptyState) emptyState.remove();
                
                // Add each patch
                patches.forEach(patch => {
                    const patchName = patch.getAttribute('Name');
                    const patchNumber = patch.getAttribute('Number');
                    const programChange = patch.getAttribute('ProgramChange');
                    
                    if (patchName && patchNumber !== null) {
                        // Store program change number for MIDI switching
                        if (programChange !== null) {
                            patchProgramChanges[patchName] = parseInt(programChange);
                        } else {
                            patchProgramChanges[patchName] = parseInt(patchNumber);
                        }
                        
                        // Find Note List references for this patch
                        const usesNoteList = patch.querySelector('UsesNoteNameList');
                        const noteListName = usesNoteList ? usesNoteList.getAttribute('Name') : null;
                        
                        const patchDiv = document.createElement('div');
                        patchDiv.className = 'patch-item';
                        patchDiv.dataset.patchName = patchName;
                        patchDiv.dataset.bankName = bankName;
                        patchDiv.innerHTML = `
                            <div class="patch-header">
                                <div class="patch-info-inline">
                                    <span class="patch-number">#${patchNumber}</span>
                                    <span class="patch-name">${patchName}</span>
                                    <span class="patch-program-change">PC: <button class="patch-program-change-btn" onclick="sendMIDIProgramChange(${programChange || patchNumber})" title="Send Program Change ${programChange || patchNumber}">${programChange || patchNumber}</button></span>
                                </div>
                                <div class="patch-actions">
                                    <button class="btn btn-small btn-primary" onclick="selectPatch('${bankName}', '${patchName}', '${patchNumber}', '${programChange || patchNumber}')">Edit Patch</button>
                                    <button class="btn btn-small btn-secondary" onclick="editPatch('${bankName}', '${patchName}', '${patchNumber}', '${programChange || patchNumber}')">Settings</button>
                                    <button class="btn btn-small btn-secondary" onclick="${noteListName ? `editNoteNameList('${noteListName}', '${bankName}', '${patchName}', '${patchNumber}', '${programChange || patchNumber}')` : `addNoteListToPatch('${bankName}', '${patchName}')`}">${noteListName ? 'Edit Note Names' : 'Add Note Names'}</button>
                                    <button class="btn btn-small btn-danger" onclick="removePatch(this)">Remove</button>
                                </div>
                            </div>
                            <div class="patch-details">
                            </div>
                        `;
                        
                        container.appendChild(patchDiv);
                    }
                });
                
                alert(`Loaded ${patches.length} patches from ${bankName}`);
                
            } catch (error) {
                console.error('Error loading patches from XML:', error);
                alert(`Error loading patches: ${error.message}`);
            }
        }

        function editNoteNameList(name, bankName, patchName, patchNumber, programChange) {
            // Set the selected patch context
            selectedPatch = {
                bankName: bankName,
                name: patchName,
                number: patchNumber,
                programChange: programChange
            };
            
            // Update patch tab info
            document.getElementById('selected-patch').textContent = `${patchName} (#${patchNumber})`;
            
            // Switch to Patch tab for editing
            document.querySelector('[data-tab="patch"]').click();
            
            // Load the note data from the current device XML
            loadNoteListDataFromCurrentDevice(name);
            
            // Populate patch dropdown with available kits
            populatePatchDropdown();
            
            // Set the correct patch in the dropdown
            const patchSelect = document.getElementById('patch-select');
            if (patchSelect) {
                patchSelect.value = `${bankName}|${patchName}`;
            }
        }

        function loadNoteListDataFromCurrentDevice(listName) {
            try {
                if (!currentMidnam) {
                    alert('No device XML loaded. Please select a device first.');
                    return;
                }
                
                // Find the NoteNameList in the current device XML
                const noteNameLists = currentMidnam.querySelectorAll('NoteNameList');
                let targetList = null;
                
                for (let noteList of noteNameLists) {
                    if (noteList.getAttribute('Name') === listName) {
                        targetList = noteList;
                        break;
                    }
                }
                
                if (targetList) {
                    // Initialize the note editor with the loaded data and context
                    initializeNoteEditorWithData(selectedDevice, targetList, selectedPatch);
                } else {
                    alert(`Note Name List "${listName}" not found in current device XML`);
                }
                
            } catch (error) {
                alert(`Error loading note list data: ${error.message}`);
            }
        }

        async function loadNoteListData(listName) {
            try {
                const response = await fetch('/load_d4.php');
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const xmlText = await response.text();
                const parser = new DOMParser();
                const xmlDoc = parser.parseFromString(xmlText, 'text/xml');
                
                // Find the specific note name list
                const noteNameLists = xmlDoc.querySelectorAll('NoteNameList');
                let targetList = null;
                
                for (let noteList of noteNameLists) {
                    if (noteList.getAttribute('Name') === listName) {
                        targetList = noteList;
                        break;
                    }
                }
                
                if (targetList) {
                    // Initialize the note editor with the loaded data
                    initializeNoteEditorWithData(selectedDevice, targetList, selectedPatch);
                } else {
                    alert(`Note Name List "${listName}" not found in D4.midnam`);
                }
                
            } catch (error) {
                alert(`Error loading note list data: ${error.message}`);
            }
        }

        function initializeNoteEditorWithData(device, noteList, patchContext) {
            const container = document.getElementById('patch-editor-container');
            
            // Get all notes from the XML
            const notes = noteList.querySelectorAll('Note');
            const noteData = [];
            
            notes.forEach(note => {
                const number = note.getAttribute('Number');
                const name = note.getAttribute('Name');
                if (number && name) {
                    noteData.push({ number: parseInt(number), name: name });
                }
            });
            
            // Sort by note number
            noteData.sort((a, b) => a.number - b.number);
            
            // Create label with bank and patch information if available
            let labelText = `Note Names for ${device.name}`;
            if (patchContext && patchContext.bankName && patchContext.name) {
                labelText = `Note Names for ${device.name}: ${patchContext.bankName} : ${patchContext.name}`;
            }
            
            // Create the note editor interface
            container.innerHTML = `
                <div class="structure-item">
                    <h3>${labelText}</h3>
                    <p>Editing: <strong>${noteList.getAttribute('Name')}</strong> (${noteData.length} notes loaded)</p>
                    
                    <div class="note-editor-controls">
                        <div class="form-group">
                            <label for="note-list-select">Note Name List:</label>
                            <select id="note-list-select">
                                <option value="${noteList.getAttribute('Name')}" selected>${noteList.getAttribute('Name')}</option>
                            </select>
                        </div>
                        
                        <div class="form-group">
                            <button class="btn btn-primary" onclick="addNote()">Add Note</button>
                            <button class="btn btn-secondary" onclick="importNotes()">Import</button>
                            <button class="btn btn-secondary" onclick="exportNotes()">Export</button>
                        </div>
                    </div>
                    
                    <div id="note-editor-content" style="display: block;">
                        <div class="note-editor-header">
                            <h4>Note Mappings</h4>
                            <div class="note-editor-actions">
                                <button class="btn btn-small btn-primary" onclick="addNote()">Add Note</button>
                                <button class="btn btn-small btn-secondary" onclick="importNotes()">Import</button>
                                <button class="btn btn-small btn-secondary" onclick="exportNotes()">Export</button>
                            </div>
                        </div>
                        
                        <div class="note-table-container">
                            <table class="note-table" id="note-table">
                                <thead>
                                    <tr>
                                        <th>Note #</th>
                                        <th>Note Name</th>
                                        <th>Actions</th>
                                    </tr>
                                </thead>
                                <tbody id="note-table-body">
                                </tbody>
                            </table>
                        </div>
                    </div>
                </div>
            `;
            
            // Populate the table with loaded data
            const tableBody = document.getElementById('note-table-body');
            noteData.forEach(note => {
                addNoteRow(note.number, note.name);
            });
        }

        function editNoteNameListSettings(name) {
            alert(`Edit Note Name List Settings "${name}" - Not yet implemented`);
        }

        function populatePatchDropdown() {
            const patchSelect = document.getElementById('patch-select');
            patchSelect.innerHTML = '<option value="">Select a patch...</option>';
            
            // Get all patch banks and their stored data
            const patchBanks = document.querySelectorAll('.structure-element[data-patch-bank-data]');
            patchBanks.forEach(bankElement => {
                const patchBankData = bankElement.dataset.patchBankData;
                if (patchBankData) {
                    try {
                        const data = JSON.parse(patchBankData);
                        data.patches.forEach(patch => {
                            if (patch.name && patch.number !== null) {
                                const option = document.createElement('option');
                                option.value = `${data.name}|${patch.name}`;
                                option.textContent = `${data.name} - ${patch.name}`;
                                patchSelect.appendChild(option);
                            }
                        });
                    } catch (error) {
                        console.error('Error parsing patch bank data:', error);
                    }
                }
            });
        }

        function getBankSelectInfo(patchBank, bankIndex = null) {
            const midiCommands = patchBank.querySelector('MIDICommands');
            
            if (midiCommands) {
                // Bank has explicit MIDI commands
                const controlChanges = midiCommands.querySelectorAll('ControlChange');
                const commands = [];
                
                controlChanges.forEach(cc => {
                    const control = cc.getAttribute('Control');
                    const value = cc.getAttribute('Value');
                    commands.push({ control: parseInt(control), value: parseInt(value) });
                });
                
                return {
                    type: 'explicit',
                    commands: commands,
                    displayText: commands.map(cmd => `CC#${cmd.control}=${cmd.value}`).join(', ')
                };
            } else {
                // No explicit commands - use unverified bank select
                if (bankIndex !== null) {
                    return {
                        type: 'unverified',
                        commands: [
                            { control: 0, value: 0 },
                            { control: 32, value: bankIndex }
                        ],
                        displayText: `CC#0=0, CC#32=${bankIndex} (unverified)`
                    };
                } else {
                    return {
                        type: 'none',
                        commands: [],
                        displayText: 'No bank select required'
                    };
                }
            }
        }

        function sendBankSelectCommands(commands) {
            const output = getMIDIOutput();
            if (!output || !midiEnabled) {
                console.log('MIDI not enabled or no output device selected - skipping bank select commands');
                return;
            }
            
            if (commands.length === 0) {
                console.log('No bank select commands to send');
                return;
            }
            
            // Send each command with a small delay
            commands.forEach((cmd, index) => {
                setTimeout(() => {
                    try {
                        output.send([0xB0, cmd.control, cmd.value]);
                        console.log(`Sent bank select: CC#${cmd.control}=${cmd.value}`);
                    } catch (error) {
                        console.error('Error sending bank select command:', error);
                        alert(`Error sending bank select command: ${error.message}`);
                    }
                }, index * 50); // 50ms delay between commands
            });
        }

        function loadPatchNoteList(bankName, patchName) {
            if (!currentMidnam) {
                // No device XML loaded, show empty patch editor
                initializePatchEditor({ bankName, name: patchName, number: '?', programChange: '?' });
                return;
            }
            
            const midnamDoc = currentMidnam.querySelector('MIDINameDocument');
            if (!midnamDoc) {
                // No valid MIDI name document, show empty patch editor
                initializePatchEditor({ bankName, name: patchName, number: '?', programChange: '?' });
                return;
            }
            
            // Find the patch bank
            const patchBank = midnamDoc.querySelector(`PatchBank[Name="${bankName}"]`);
            if (!patchBank) {
                // Patch bank not found, show empty patch editor
                initializePatchEditor({ bankName, name: patchName, number: '?', programChange: '?' });
                return;
            }
            
            // Find the specific patch
            const patchElement = patchBank.querySelector(`Patch[Name="${patchName}"]`);
            if (!patchElement) {
                // Patch not found, show empty patch editor
                initializePatchEditor({ bankName, name: patchName, number: '?', programChange: '?' });
                return;
            }
            
            // Get patch details
            const patchNumber = patchElement.getAttribute('Number') || '?';
            const programChange = patchElement.getAttribute('ProgramChange') || patchNumber;
            
            // Check if the patch references a note list
            const usesNoteNameList = patchElement.querySelector('UsesNoteNameList');
            if (!usesNoteNameList) {
                // No note list referenced, show empty patch editor
                initializePatchEditor({ bankName, name: patchName, number: patchNumber, programChange });
                return;
            }
            
            const noteListName = usesNoteNameList.getAttribute('Name');
            if (!noteListName) {
                // Note list name not specified, show empty patch editor
                initializePatchEditor({ bankName, name: patchName, number: patchNumber, programChange });
                return;
            }
            
            // Find the note list
            const noteNameLists = midnamDoc.querySelectorAll('NoteNameList');
            let targetList = null;
            
            for (let noteList of noteNameLists) {
                if (noteList.getAttribute('Name') === noteListName) {
                    targetList = noteList;
                    break;
                }
            }
            
            if (targetList) {
                // Found the note list, initialize the editor with it
                initializeNoteEditorWithData(selectedDevice, targetList, { bankName, name: patchName, number: patchNumber, programChange });
            } else {
                // Note list not found, show empty patch editor
                initializePatchEditor({ bankName, name: patchName, number: patchNumber, programChange });
            }
        }

        function switchPatch(patchValue) {
            if (!patchValue) return;
            
            // Parse bank and patch name from the value
            const [bankName, patchName] = patchValue.split('|');
            
            // Update the selected patch display
            document.getElementById('selected-patch').textContent = `${bankName} - ${patchName}`;
            
            // Send bank select commands first, then program change
            sendBankSelectForPatch(bankName, patchName);
            
            // Try to find and load the note list referenced by this patch
            loadPatchNoteList(bankName, patchName);
        }

        function sendBankSelectForPatch(bankName, patchName) {
            if (!currentMidnam) return;
            
            const midnamDoc = currentMidnam.querySelector('MIDINameDocument');
            if (!midnamDoc) return;
            
            // Find the patch bank
            const patchBank = midnamDoc.querySelector(`PatchBank[Name="${bankName}"]`);
            if (!patchBank) return;
            
            // Get bank select information - use the stored data from the bank element
            const bankElement = document.querySelector(`[onclick="togglePatchBank('${bankName}')"]`)?.closest('.structure-element');
            let bankSelectInfo = null;
            
            if (bankElement && bankElement.dataset.patchBankData) {
                try {
                    const bankData = JSON.parse(bankElement.dataset.patchBankData);
                    bankSelectInfo = bankData.bankSelectInfo;
                } catch (error) {
                    console.error('Error parsing bank data:', error);
                }
            }
            
            // Fallback: generate bank select info if not stored
            if (!bankSelectInfo) {
                const bankIndex = Array.from(document.querySelectorAll('.structure-element')).findIndex(el => 
                    el.querySelector('.element-name')?.textContent.includes(bankName)
                );
                bankSelectInfo = getBankSelectInfo(patchBank, bankIndex >= 0 ? bankIndex : null);
            }
            
            // Send bank select commands if available
            if (bankSelectInfo && bankSelectInfo.commands.length > 0) {
                console.log(`Sending bank select for ${bankName}:`, bankSelectInfo.commands);
                sendBankSelectCommands(bankSelectInfo.commands);
            }
            
            // Send program change after bank select
            if (patchProgramChanges[patchName] !== undefined) {
                // Add delay to ensure bank select commands are processed first
                setTimeout(() => {
                    sendMIDIProgramChange(patchProgramChanges[patchName]);
                }, 100);
            }
        }

        function convertToCatalogName(fullManufacturerName) {
            // Convert full manufacturer names to catalog names
            const nameMap = {
                'Alesis Studio Electronics': 'Alesis',
                'Yamaha Corporation': 'Yamaha',
                'Roland Corporation': 'Roland',
                'Korg Inc': 'Korg',
                'Kawai Musical Instruments': 'Kawai',
                'Casio Computer Co Ltd': 'Casio',
                'Akai Electric Co Ltd': 'Akai',
                'Sony Corporation': 'Sony',
                'Behringer GmbH': 'Behringer',
                'Arturia': 'ART',
                'Novation': 'Novation',
                'M-Audio': 'M-Audio',
                'E-Mu Systems': 'E-mu',
                'Ensoniq': 'Ensoniq',
                'Kurzweil': 'Kurzweil',
                'Oberheim': 'Oberheim',
                'Sequential Circuits': 'Sequential Circuits',
                'Moog': 'Moog',
                'Dave Smith Instruments': 'Dave Smith Instruments',
                'Waldorf': 'Waldorf',
                'Access': 'Access',
                'Clavia': 'Clavia',
                'Nord': 'Clavia', // Nord is made by Clavia
                'Virus': 'Access', // Virus is made by Access
                'Propellerhead': 'Propellerhead',
                'Reason': 'Propellerhead'
            };
            
            return nameMap[fullManufacturerName] || fullManufacturerName;
        }

        // Note Editor functionality
        function initializeNoteEditor(device) {
            const container = document.getElementById('patch-editor-container');
            
            if (!device.isDrumMachine) {
                container.innerHTML = `
                    <div class="structure-item">
                        <h3>Note Names for ${device.name}</h3>
                        <p>This device is not a drum machine. Note names are typically used for drum machines and percussion devices.</p>
                        <p>You can still create note name lists for custom mappings if needed.</p>
                    </div>
                `;
                return;
            }
            
            // Create a basic note editor interface
            container.innerHTML = `
                <div class="structure-item">
                    <h3>Note Names for ${device.name}</h3>
                    <p>Configure note name mappings for this drum machine.</p>
                    
                    <div class="note-editor-controls">
                        <div class="form-group">
                            <label for="note-list-select">Note Name List:</label>
                            <select id="note-list-select">
                                <option value="">Select a note name list...</option>
                                <option value="default">Default Drum Kit</option>
                                <option value="custom">Custom Kit</option>
                            </select>
                        </div>
                        
                        <div class="form-group">
                            <button class="btn btn-primary" onclick="createDefaultNoteList()">Create Default Drum Kit</button>
                            <button class="btn btn-secondary" onclick="createCustomNoteList()">Create Custom Kit</button>
                        </div>
                    </div>
                    
                    <div id="note-editor-content" style="display: none;">
                        <div class="note-editor-header">
                            <h4>Note Mappings</h4>
                            <div class="note-editor-actions">
                                <button class="btn btn-small btn-primary" onclick="addNote()">Add Note</button>
                                <button class="btn btn-small btn-secondary" onclick="importNotes()">Import</button>
                                <button class="btn btn-small btn-secondary" onclick="exportNotes()">Export</button>
                            </div>
                        </div>
                        
                        <div class="note-table-container">
                            <table class="note-table" id="note-table">
                                <thead>
                                    <tr>
                                        <th>Note #</th>
                                        <th>Note Name</th>
                                        <th>Actions</th>
                                    </tr>
                                </thead>
                                <tbody id="note-table-body">
                                </tbody>
                            </table>
                        </div>
                    </div>
                </div>
            `;
        }

        function createDefaultNoteList() {
            const content = document.getElementById('note-editor-content');
            const tableBody = document.getElementById('note-table-body');
            
            // Create default drum kit notes
            const defaultNotes = [
                { number: 36, name: 'Kick Drum' },
                { number: 38, name: 'Snare Drum' },
                { number: 40, name: 'Snare Drum 2' },
                { number: 42, name: 'Hi-Hat Closed' },
                { number: 44, name: 'Hi-Hat Pedal' },
                { number: 46, name: 'Hi-Hat Open' },
                { number: 47, name: 'Low Tom' },
                { number: 48, name: 'Hi Tom' },
                { number: 49, name: 'Crash Cymbal' },
                { number: 51, name: 'Ride Cymbal' }
            ];
            
            tableBody.innerHTML = '';
            defaultNotes.forEach(note => {
                addNoteRow(note.number, note.name);
            });
            
            content.style.display = 'block';
            document.getElementById('note-list-select').value = 'default';
        }

        function createCustomNoteList() {
            const content = document.getElementById('note-editor-content');
            const tableBody = document.getElementById('note-table-body');
            
            tableBody.innerHTML = '';
            addNoteRow(36, midiNoteToName(36));
            
            content.style.display = 'block';
            document.getElementById('note-list-select').value = 'custom';
        }

        function addNoteRow(number, name) {
            const tableBody = document.getElementById('note-table-body');
            const row = document.createElement('tr');
            
            // Add piano key styling classes
            if (isBlackKey(number)) {
                row.classList.add('black-key');
            }
            if (number === 60) {
                row.classList.add('middle-c');
            }
            
            // Get chromatic note name
            const chromaticName = midiNoteToName(number);
            
            // Create note number cell with tooltip functionality
            const noteNumberCell = document.createElement('td');
            const noteNumberDiv = document.createElement('div');
            noteNumberDiv.className = 'note-number-cell';
            noteNumberDiv.textContent = `${number} (${chromaticName})`;
            noteNumberDiv.title = 'Click to play this note';
            noteNumberDiv.onclick = () => playMIDINote(number);
            
            // Add tooltip event listeners
            noteNumberDiv.addEventListener('mouseenter', (e) => showKeyboardTooltip(e, number));
            noteNumberDiv.addEventListener('mouseleave', hideKeyboardTooltip);
            noteNumberDiv.addEventListener('mousemove', (e) => updateTooltipPosition(e));
            
            noteNumberCell.appendChild(noteNumberDiv);
            
            // Create note name input cell with dropdown
            const noteNameCell = document.createElement('td');
            noteNameCell.className = 'note-name-cell';
            
            const noteNameInput = document.createElement('input');
            noteNameInput.type = 'text';
            noteNameInput.value = name;
            noteNameInput.className = 'note-name-input';
            noteNameInput.placeholder = 'Note name';
            noteNameInput.setAttribute('data-note-number', number);
            
            // Add event listeners for dropdown functionality
            noteNameInput.addEventListener('input', handleNoteNameInput);
            noteNameInput.addEventListener('focus', showNoteDropdown);
            noteNameInput.addEventListener('blur', () => setTimeout(hideNoteDropdown, 200));
            noteNameInput.addEventListener('keydown', handleNoteKeyDown);
            
            // Create dropdown
            const dropdown = document.createElement('div');
            dropdown.className = 'note-dropdown';
            
            noteNameCell.appendChild(noteNameInput);
            noteNameCell.appendChild(dropdown);
            
            // Create actions cell with both add and remove buttons
            const actionsCell = document.createElement('td');
            actionsCell.className = 'note-actions';
            
            // Add/Insert button
            const addBtn = document.createElement('button');
            addBtn.className = 'btn btn-small btn-success add-note-btn';
            addBtn.textContent = '+';
            addBtn.title = 'Add note after this one';
            addBtn.onclick = () => addNoteAfter(number);
            addBtn.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' || e.key === ' ') {
                    e.preventDefault();
                    addNoteAfter(number);
                }
            });
            
            // Remove button
            const removeBtn = document.createElement('button');
            removeBtn.className = 'btn btn-small btn-danger remove-note-btn';
            removeBtn.textContent = '';
            removeBtn.title = 'Remove this note';
            removeBtn.tabIndex = -1; // Exclude from tab focus for safety
            removeBtn.onclick = () => removeNote(removeBtn);
            
            // Add both buttons to actions cell
            actionsCell.appendChild(addBtn);
            actionsCell.appendChild(removeBtn);
            
            // Append all cells to row
            row.appendChild(noteNumberCell);
            row.appendChild(noteNameCell);
            row.appendChild(actionsCell);
            
            tableBody.appendChild(row);
        }

        function addNote() {
            // Find the highest note number and add one
            const existingNumbers = Array.from(document.querySelectorAll('.note-name-input'))
                .map(input => parseInt(input.getAttribute('data-note-number')))
                .filter(num => !isNaN(num))
                .sort((a, b) => b - a);
            
            const nextNumber = existingNumbers.length > 0 ? existingNumbers[0] + 1 : 36;
            addNoteRow(nextNumber, midiNoteToName(nextNumber));
        }

        function addNoteAfter(afterNumber) {
            const tableBody = document.getElementById('note-table-body');
            const rows = Array.from(tableBody.querySelectorAll('tr'));
            
            // Find the row with the specified note number
            let insertIndex = -1;
            for (let i = 0; i < rows.length; i++) {
                const noteNumberInput = rows[i].querySelector('input[data-note-number]');
                if (noteNumberInput && parseInt(noteNumberInput.getAttribute('data-note-number')) === afterNumber) {
                    insertIndex = i;
                    break;
                }
            }
            
            if (insertIndex === -1) {
                // If note not found, just add at the end
                addNote();
                return;
            }
            
            // Get all existing note numbers to find the next available number
            const existingNumbers = Array.from(tableBody.querySelectorAll('input[data-note-number]'))
                .map(input => parseInt(input.getAttribute('data-note-number')))
                .filter(num => !isNaN(num))
                .sort((a, b) => a - b);
            
            // Find the next available number after the specified number
            let nextNumber = afterNumber + 1;
            while (existingNumbers.includes(nextNumber)) {
                nextNumber++;
            }
            
            // Create the new row
            const newRow = document.createElement('tr');
            
            // Add piano key styling classes
            if (isBlackKey(nextNumber)) {
                newRow.classList.add('black-key');
            }
            if (nextNumber === 60) {
                newRow.classList.add('middle-c');
            }
            
            // Get chromatic note name
            const chromaticName = midiNoteToName(nextNumber);
            
            // Create note number cell with tooltip functionality
            const noteNumberCell = document.createElement('td');
            const noteNumberDiv = document.createElement('div');
            noteNumberDiv.className = 'note-number-cell';
            noteNumberDiv.textContent = `${nextNumber} (${chromaticName})`;
            noteNumberDiv.title = 'Click to play this note';
            noteNumberDiv.onclick = () => playMIDINote(nextNumber);
            
            // Add tooltip event listeners
            noteNumberDiv.addEventListener('mouseenter', (e) => showKeyboardTooltip(e, nextNumber));
            noteNumberDiv.addEventListener('mouseleave', hideKeyboardTooltip);
            noteNumberDiv.addEventListener('mousemove', (e) => updateTooltipPosition(e));
            
            noteNumberCell.appendChild(noteNumberDiv);
            
            // Create note name input cell with dropdown
            const noteNameCell = document.createElement('td');
            noteNameCell.className = 'note-name-cell';
            
            const noteNameInput = document.createElement('input');
            noteNameInput.type = 'text';
            noteNameInput.value = midiNoteToName(nextNumber);
            noteNameInput.className = 'note-name-input';
            noteNameInput.placeholder = 'Note name';
            noteNameInput.setAttribute('data-note-number', nextNumber);
            
            // Add event listeners for dropdown functionality
            noteNameInput.addEventListener('input', handleNoteNameInput);
            noteNameInput.addEventListener('focus', showNoteDropdown);
            noteNameInput.addEventListener('blur', () => setTimeout(hideNoteDropdown, 200));
            noteNameInput.addEventListener('keydown', handleNoteKeyDown);
            
            // Create dropdown
            const dropdown = document.createElement('div');
            dropdown.className = 'note-dropdown';
            
            noteNameCell.appendChild(noteNameInput);
            noteNameCell.appendChild(dropdown);
            
            // Create actions cell with both add and remove buttons
            const actionsCell = document.createElement('td');
            actionsCell.className = 'note-actions';
            
            // Add/Insert button
            const addBtn = document.createElement('button');
            addBtn.className = 'btn btn-small btn-success add-note-btn';
            addBtn.textContent = '+';
            addBtn.title = 'Add note after this one';
            addBtn.onclick = () => addNoteAfter(nextNumber);
            addBtn.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' || e.key === ' ') {
                    e.preventDefault();
                    addNoteAfter(nextNumber);
                }
            });
            
            // Remove button
            const removeBtn = document.createElement('button');
            removeBtn.className = 'btn btn-small btn-danger remove-note-btn';
            removeBtn.textContent = '';
            removeBtn.title = 'Remove this note';
            removeBtn.tabIndex = -1; // Exclude from tab focus for safety
            removeBtn.onclick = () => removeNote(removeBtn);
            
            // Add both buttons to actions cell
            actionsCell.appendChild(addBtn);
            actionsCell.appendChild(removeBtn);
            
            // Append all cells to row
            newRow.appendChild(noteNumberCell);
            newRow.appendChild(noteNameCell);
            newRow.appendChild(actionsCell);
            
            // Insert the new row after the specified note
            if (insertIndex + 1 < rows.length) {
                tableBody.insertBefore(newRow, rows[insertIndex + 1]);
            } else {
                tableBody.appendChild(newRow);
            }
            
            // Focus on the new note name input for immediate editing
            setTimeout(() => {
                noteNameInput.focus();
                noteNameInput.select();
            }, 100);
        }

        function removeNote(button) {
            if (confirm('Remove this note?')) {
                button.closest('tr').remove();
            }
        }

        // Global set to store all note names for autocomplete
        let allNoteNames = new Set();

        // Initialize note names from common drum sounds and current device
        function initializeNoteNames() {
            // Start with common drum sound names
            const commonNoteNames = [
                'Kick', 'Snare', 'Hi-Hat Closed', 'Hi-Hat Open', 'Crash', 'Ride',
                'Tom 1', 'Tom 2', 'Tom 3', 'Tom 4', 'Tom 5', 'Tom 6',
                'Rim Shot', 'Clap', 'Cowbell', 'Tambourine', 'Shaker',
                'Open Hi-Hat', 'Closed Hi-Hat', 'Pedal Hi-Hat',
                'Crash 1', 'Crash 2', 'Ride 1', 'Ride 2',
                'Splash', 'China', 'Bell', 'Wood Block',
                'Hand Clap', 'Finger Snap', 'Stick Click',
                'Brush Tap', 'Brush Swirl', 'Brush Slap',
                'Side Stick', 'Rim Click', 'Cross Stick',
                'Low Tom', 'Mid Tom', 'High Tom',
                'Floor Tom 1', 'Floor Tom 2',
                'Bass Drum', 'Kick Drum', 'Sub Kick',
                'Snare Roll', 'Snare Ghost', 'Snare Rim',
                'Hi-Hat Foot', 'Hi-Hat Splash', 'Hi-Hat Chick'
            ];
            
            commonNoteNames.forEach(name => allNoteNames.add(name));
            
            // Add note names from current device if available
            if (currentMidnam) {
                const deviceNoteNames = extractAllNoteNamesFromDevice();
                deviceNoteNames.forEach(name => allNoteNames.add(name));
                console.log(`Added ${deviceNoteNames.length} note names from current device`);
            }
        }

        // Extract all note names from the current device
        function extractAllNoteNamesFromDevice() {
            const noteNames = new Set();
            
            if (!currentMidnam) return Array.from(noteNames);
            
            const midnamDoc = currentMidnam.querySelector('MIDINameDocument');
            if (!midnamDoc) return Array.from(noteNames);
            
            // Get all NoteNameList elements
            const noteNameLists = midnamDoc.querySelectorAll('NoteNameList');
            noteNameLists.forEach(noteList => {
                const notes = noteList.querySelectorAll('Note');
                notes.forEach(note => {
                    const name = note.getAttribute('Name');
                    if (name && name.trim()) {
                        noteNames.add(name.trim());
                    }
                });
            });
            
            return Array.from(noteNames);
        }

        // Update note names when device changes
        function updateNoteNamesForDevice() {
            // Clear existing device-specific names (keep common ones)
            const commonNoteNames = [
                'Kick', 'Snare', 'Hi-Hat Closed', 'Hi-Hat Open', 'Crash', 'Ride',
                'Tom 1', 'Tom 2', 'Tom 3', 'Tom 4', 'Tom 5', 'Tom 6',
                'Rim Shot', 'Clap', 'Cowbell', 'Tambourine', 'Shaker',
                'Open Hi-Hat', 'Closed Hi-Hat', 'Pedal Hi-Hat',
                'Crash 1', 'Crash 2', 'Ride 1', 'Ride 2',
                'Splash', 'China', 'Bell', 'Wood Block',
                'Hand Clap', 'Finger Snap', 'Stick Click',
                'Brush Tap', 'Brush Swirl', 'Brush Slap',
                'Side Stick', 'Rim Click', 'Cross Stick',
                'Low Tom', 'Mid Tom', 'High Tom',
                'Floor Tom 1', 'Floor Tom 2',
                'Bass Drum', 'Kick Drum', 'Sub Kick',
                'Snare Roll', 'Snare Ghost', 'Snare Rim',
                'Hi-Hat Foot', 'Hi-Hat Splash', 'Hi-Hat Chick'
            ];
            
            // Rebuild the set with common names
            allNoteNames.clear();
            commonNoteNames.forEach(name => allNoteNames.add(name));
            
            // Add device-specific names
            if (currentMidnam) {
                const deviceNoteNames = extractAllNoteNamesFromDevice();
                deviceNoteNames.forEach(name => allNoteNames.add(name));
                console.log(`Updated note names: ${allNoteNames.size} total (${deviceNoteNames.length} from device)`);
            }
        }

        // Handle note name input with autocomplete
        function handleNoteNameInput(event) {
            const input = event.target;
            const value = input.value.toLowerCase();
            const dropdown = input.parentNode.querySelector('.note-dropdown');
            
            // Filter note names
            const matches = Array.from(allNoteNames).filter(name => 
                name.toLowerCase().includes(value) && name !== input.value
            ).slice(0, 10);
            
            if (matches.length > 0 && value.length > 0) {
                dropdown.innerHTML = '';
                matches.forEach((match, index) => {
                    const item = document.createElement('div');
                    item.className = 'note-dropdown-item';
                    item.textContent = match;
                    item.dataset.index = index;
                    item.onclick = () => {
                        input.value = match;
                        hideNoteDropdown();
                        // Add to autocomplete index if it's a new name
                        if (!allNoteNames.has(match)) {
                            allNoteNames.add(match);
                        }
                    };
                    dropdown.appendChild(item);
                });
                dropdown.style.display = 'block';
                
                // Reset selection
                input.dataset.selectedIndex = -1;
            } else {
                hideNoteDropdown();
            }
        }

        function showNoteDropdown(event) {
            const dropdown = event.target.parentNode.querySelector('.note-dropdown');
            if (dropdown.children.length > 0) {
                dropdown.style.display = 'block';
            }
        }

        function hideNoteDropdown() {
            document.querySelectorAll('.note-dropdown').forEach(dropdown => {
                dropdown.style.display = 'none';
            });
        }

        // Handle keyboard navigation in dropdown
        function handleNoteKeyDown(event) {
            const input = event.target;
            const dropdown = input.parentNode.querySelector('.note-dropdown');
            const items = dropdown.querySelectorAll('.note-dropdown-item');
            
            switch (event.key) {
                case 'ArrowDown':
                    if (items.length > 0) {
                        event.preventDefault();
                        let selectedIndex = parseInt(input.dataset.selectedIndex || -1);
                        selectedIndex = Math.min(selectedIndex + 1, items.length - 1);
                        updateNoteSelection(items, selectedIndex);
                        input.dataset.selectedIndex = selectedIndex;
                    }
                    break;
                    
                case 'ArrowUp':
                    if (items.length > 0) {
                        event.preventDefault();
                        let selectedIndex = parseInt(input.dataset.selectedIndex || -1);
                        selectedIndex = Math.max(selectedIndex - 1, -1);
                        updateNoteSelection(items, selectedIndex);
                        input.dataset.selectedIndex = selectedIndex;
                    }
                    break;
                    
                case 'Enter':
                case 'Return':
                    event.preventDefault();
                    // Check if dropdown is visible by checking its display style
                    const isDropdownVisible = dropdown.style.display === 'block' && items.length > 0;
                    
                    if (isDropdownVisible) {
                        // Dropdown is visible - select from dropdown
                        let selectedIndex = parseInt(input.dataset.selectedIndex || -1);
                        if (selectedIndex >= 0 && items[selectedIndex]) {
                            input.value = items[selectedIndex].textContent;
                            hideNoteDropdown();
                            // Add to autocomplete index if it's a new name
                            if (!allNoteNames.has(input.value)) {
                                allNoteNames.add(input.value);
                            }
                        }
                    } else {
                        // No dropdown visible - commit changes and move to Add button
                        hideNoteDropdown();
                        const addButton = input.closest('tr').querySelector('.add-note-btn');
                        if (addButton) {
                            addButton.focus();
                        }
                    }
                    break;
                    
                case 'Escape':
                    event.preventDefault();
                    hideNoteDropdown();
                    input.dataset.selectedIndex = -1;
                    break;
                    
                case 'Tab':
                    // Allow normal tab behavior
                    hideNoteDropdown();
                    break;
            }
        }

        // Update visual selection in dropdown
        function updateNoteSelection(items, selectedIndex) {
            items.forEach((item, index) => {
                if (index === selectedIndex) {
                    item.classList.add('selected');
                } else {
                    item.classList.remove('selected');
                }
            });
        }

        // Collect note data from the editor
        function collectNoteDataFromEditor() {
            const noteData = [];
            const tableBody = document.getElementById('note-table-body');
            
            if (!tableBody) {
                console.log('No note table body found');
                return noteData;
            }
            
            const rows = tableBody.querySelectorAll('tr');
            rows.forEach(row => {
                const noteNumberInput = row.querySelector('input[data-note-number]');
                const noteNameInput = row.querySelector('.note-name-input');
                
                if (noteNumberInput && noteNameInput) {
                    const number = parseInt(noteNumberInput.getAttribute('data-note-number'));
                    const name = noteNameInput.value.trim();
                    
                    if (!isNaN(number)) {
                        noteData.push({ number, name: name || '' });
                    }
                }
            });
            
            // Sort by note number
            noteData.sort((a, b) => a.number - b.number);
            
            console.log('Collected note data:', noteData);
            return noteData;
        }

        // Save note data to patch
        async function saveNoteDataToPatch(patchContext, noteData) {
            try {
                if (!currentMidnam) {
                    alert('No device XML loaded. Please select a device first.');
                    return;
                }
                
                const midnamDoc = currentMidnam.querySelector('MIDINameDocument');
                if (!midnamDoc) {
                    alert('Invalid MIDI name document');
                    return;
                }
                
                // Find the patch bank
                const patchBank = midnamDoc.querySelector(`PatchBank[Name="${patchContext.bankName}"]`);
                if (!patchBank) {
                    alert(`Patch bank "${patchContext.bankName}" not found`);
                    return;
                }
                
                // Find the specific patch
                const patchElement = patchBank.querySelector(`Patch[Name="${patchContext.name}"]`);
                if (!patchElement) {
                    alert(`Patch "${patchContext.name}" not found`);
                    return;
                }
                
                // Find or create the note list reference
                let usesNoteNameList = patchElement.querySelector('UsesNoteNameList');
                let noteListName = null;
                
                if (usesNoteNameList) {
                    noteListName = usesNoteNameList.getAttribute('Name');
                } else {
                    // Create a new note list reference
                    noteListName = `${patchContext.name} Notes`;
                    usesNoteNameList = document.createElement('UsesNoteNameList');
                    usesNoteNameList.setAttribute('Name', noteListName);
                    patchElement.appendChild(usesNoteNameList);
                }
                
                // Find or create the note list
                let noteList = midnamDoc.querySelector(`NoteNameList[Name="${noteListName}"]`);
                if (!noteList) {
                    // Create a new note list
                    noteList = document.createElement('NoteNameList');
                    noteList.setAttribute('Name', noteListName);
                    midnamDoc.appendChild(noteList);
                }
                
                // Update existing notes and add new ones (don't clear all)
                const existingNotes = noteList.querySelectorAll('Note');
                const existingNoteMap = new Map();
                
                // Create a map of existing notes by number
                existingNotes.forEach(note => {
                    const number = parseInt(note.getAttribute('Number'));
                    if (!isNaN(number)) {
                        existingNoteMap.set(number, note);
                    }
                });
                
                // Update or add notes from the editor
                noteData.forEach(note => {
                    if (existingNoteMap.has(note.number)) {
                        // Update existing note
                        const existingNote = existingNoteMap.get(note.number);
                        existingNote.setAttribute('Name', note.name);
                    } else {
                        // Add new note with proper formatting
                        const noteElement = document.createElement('Note');
                        noteElement.setAttribute('Number', note.number);
                        noteElement.setAttribute('Name', note.name);
                        
                        // Add proper indentation and newline before the note
                        const indentBefore = document.createTextNode('\n\t\t\t\t');
                        noteList.appendChild(indentBefore);
                        noteList.appendChild(noteElement);
                    }
                });
                
                // SAFETY: We do NOT remove notes that aren't in the editor
                // This prevents accidentally deleting notes that weren't loaded into the editor
                // Only update existing notes and add new ones - preserve everything else
                
                // Ensure proper formatting at the end of the note list
                const lastChild = noteList.lastChild;
                if (lastChild && lastChild.nodeType === Node.ELEMENT_NODE) {
                    // Add final newline and indentation after the last note
                    const finalIndent = document.createTextNode('\n\t\t\t');
                    noteList.appendChild(finalIndent);
                }
                
                // Update the current XML
                currentMidnam = midnamDoc.ownerDocument;
                
                // Save the file to disk
                await saveFileToDisk(midnamDoc.ownerDocument);
                
                alert(`Successfully saved ${noteData.length} notes for patch "${patchContext.name}"`);
                console.log('Saved note data:', noteData);
                
            } catch (error) {
                console.error('Error saving note data:', error);
                alert(`Error saving note data: ${error.message}`);
            }
        }

        // Format XML string with proper indentation and line breaks
        function formatXMLString(xmlString) {
            // Simple XML formatting - add line breaks after closing tags
            let formatted = xmlString
                .replace(/></g, '>\n<')  // Add line breaks between tags
                .replace(/^\s*\n/gm, '')  // Remove empty lines
                .replace(/\n\s*\n/g, '\n'); // Remove multiple consecutive empty lines
            
            // Add proper indentation
            const lines = formatted.split('\n');
            let indentLevel = 0;
            const indentedLines = lines.map(line => {
                const trimmed = line.trim();
                if (!trimmed) return '';
                
                // Decrease indent for closing tags
                if (trimmed.startsWith('</')) {
                    indentLevel = Math.max(0, indentLevel - 1);
                }
                
                const indent = '\t'.repeat(indentLevel);
                const result = indent + trimmed;
                
                // Increase indent for opening tags (but not self-closing)
                if (trimmed.startsWith('<') && !trimmed.startsWith('</') && !trimmed.endsWith('/>')) {
                    indentLevel++;
                }
                
                return result;
            });
            
            return indentedLines.join('\n');
        }

        // Save the XML document to disk
        async function saveFileToDisk(xmlDoc) {
            try {
                // Convert XML document to string with proper formatting
                const xmlString = formatXMLString(new XMLSerializer().serializeToString(xmlDoc));
                
                // Debug: Log the selectedDevice structure
                console.log('selectedDevice:', selectedDevice);
                console.log('selectedDevice.files:', selectedDevice?.files);
                
                // Get the file path from the current device
                let filePath = null;
                
                if (selectedDevice && selectedDevice.currentFile) {
                    // Use the currently loaded file
                    filePath = selectedDevice.currentFile.path;
                } else if (selectedDevice && selectedDevice.files && selectedDevice.files.length > 0) {
                    // Use the first file's path
                    filePath = selectedDevice.files[0].path;
                } else if (selectedDevice && selectedDevice.filePath) {
                    // Fallback to direct filePath property
                    filePath = selectedDevice.filePath;
                } else {
                    // Try to get file path from the current XML document
                    // This happens when we're editing a loaded device
                    const midnamDoc = xmlDoc.querySelector('MIDINameDocument');
                    if (midnamDoc) {
                        // For now, use a default path based on the device name
                        const manufacturer = midnamDoc.querySelector('MasterDeviceNames Manufacturer')?.textContent || 'Unknown';
                        const model = midnamDoc.querySelector('MasterDeviceNames Model')?.textContent || 'Unknown';
                        filePath = `patchfiles/${manufacturer}/${model}.midnam`;
                    }
                }
                
                if (!filePath) {
                    throw new Error('No device file path available for saving');
                }
                
                // Send to server
                const response = await fetch('/save_file', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        file_path: filePath,
                        xml_content: xmlString
                    })
                });
                
                if (!response.ok) {
                    throw new Error(`Server error: ${response.status} ${response.statusText}`);
                }
                
                const result = await response.json();
                if (!result.success) {
                    throw new Error('Server returned error');
                }
                
                console.log('File saved successfully:', result);
                return result;
                
            } catch (error) {
                console.error('Error saving file to disk:', error);
                throw error;
            }
        }

        function importNotes() {
            alert('Import notes functionality - Not yet implemented');
        }

        function exportNotes() {
            alert('Export notes functionality - Not yet implemented');
        }

        // Patch Editor functionality
        function initializePatchEditor(patch) {
            const container = document.getElementById('patch-editor-container');
            
            container.innerHTML = `
                <div class="structure-item">
                    <h3>Patch Configuration</h3>
                    <div class="patch-info-grid">
                        <div class="info-item">
                            <div class="info-label">Patch Name</div>
                            <div class="info-value">${patch.name}</div>
                        </div>
                        <div class="info-item">
                            <div class="info-label">Patch Number</div>
                            <div class="info-value">${patch.number}</div>
                        </div>
                        <div class="info-item">
                            <div class="info-label">Program Change</div>
                            <div class="info-value">${patch.programChange}</div>
                        </div>
                        <div class="info-item">
                            <div class="info-label">Bank</div>
                            <div class="info-value">${patch.bankName}</div>
                        </div>
                    </div>
                </div>
                
                <div class="structure-item">
                    <h3>Note Name Lists</h3>
                    <div id="patch-note-lists">
                        <div class="empty-state">No note name lists assigned to this patch</div>
                    </div>
                    <div class="structure-actions">
                        <button class="btn btn-primary" onclick="addNoteListToCurrentPatch()">Add Note Name List</button>
                    </div>
                </div>
            `;
            
            // Load note list data from the current XML if available
            if (currentMidnam) {
                loadPatchNoteListsFromXML(patch);
            }
        }

        function loadPatchNoteListsFromXML(patch) {
            if (!currentMidnam) return;
            
            const midnamDoc = currentMidnam.querySelector('MIDINameDocument');
            if (!midnamDoc) return;
            
            // Find the patch bank
            const patchBank = midnamDoc.querySelector(`PatchBank[Name="${patch.bankName}"]`);
            if (!patchBank) return;
            
            // Find the specific patch
            const patchElement = patchBank.querySelector(`Patch[Name="${patch.name}"][Number="${patch.number}"]`);
            if (!patchElement) return;
            
            // Find the UsesNoteNameList element
            const usesNoteNameList = patchElement.querySelector('UsesNoteNameList');
            if (!usesNoteNameList) return;
            
            const noteListName = usesNoteNameList.getAttribute('Name');
            if (!noteListName) return;
            
            // Remove the empty state
            const container = document.getElementById('patch-note-lists');
            const emptyState = container.querySelector('.empty-state');
            if (emptyState) emptyState.remove();
            
            // Add the note list to the patch
            addNoteListToPatchDisplay(noteListName);
        }

        function addNoteListToPatchDisplay(noteListName) {
            const container = document.getElementById('patch-note-lists');
            
            const noteListDiv = document.createElement('div');
            noteListDiv.className = 'note-list-item';
            noteListDiv.innerHTML = `
                <span class="note-list-name">${noteListName}</span>
                <div class="note-list-actions">
                    <button class="btn btn-small btn-primary" onclick="editNoteNameList('${noteListName}', '${selectedPatch.bankName}', '${selectedPatch.name}', '${selectedPatch.number}', '${selectedPatch.programChange}')">Edit Note Names</button>
                    <button class="btn btn-small btn-danger" onclick="removeNoteListFromCurrentPatch(this)">Remove</button>
                </div>
            `;
            
            container.appendChild(noteListDiv);
        }

        function addNoteListToCurrentPatch() {
            if (!selectedPatch) {
                alert('No patch selected');
                return;
            }
            
            const noteListName = prompt('Enter note name list name:', `${selectedPatch.name} Notes`);
            if (!noteListName) return;
            
            const container = document.getElementById('patch-note-lists');
            const emptyState = container.querySelector('.empty-state');
            if (emptyState) emptyState.remove();
            
            const noteListDiv = document.createElement('div');
            noteListDiv.className = 'note-list-item';
            noteListDiv.innerHTML = `
                <span class="note-list-name">${noteListName}</span>
                <div class="note-list-actions">
                    <button class="btn btn-small btn-primary" onclick="editNoteListInCurrentPatch('${noteListName}')">Edit Note Names</button>
                    <button class="btn btn-small btn-danger" onclick="removeNoteListFromCurrentPatch(this)">Remove</button>
                </div>
            `;
            
            container.appendChild(noteListDiv);
        }

        function editNoteListInCurrentPatch(noteListName) {
            // Load the note list data and show the note editor
            loadNoteListDataForPatch(noteListName);
        }

        function removeNoteListFromCurrentPatch(button) {
            if (confirm('Remove this note list from the patch?')) {
                button.closest('.note-list-item').remove();
            }
        }

        async function loadNoteListDataForPatch(noteListName) {
            try {
                const response = await fetch('/load_d4.php');
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const xmlText = await response.text();
                const parser = new DOMParser();
                const xmlDoc = parser.parseFromString(xmlText, 'text/xml');
                
                // Find the specific note name list
                const noteNameLists = xmlDoc.querySelectorAll('NoteNameList');
                let targetList = null;
                
                for (let noteList of noteNameLists) {
                    if (noteList.getAttribute('Name') === noteListName) {
                        targetList = noteList;
                        break;
                    }
                }
                
                if (targetList) {
                    // Initialize the note editor with the loaded data
                    initializeNoteEditorWithData(selectedDevice, targetList, selectedPatch);
                } else {
                    // Create a new note list
                    initializeNewNoteEditor(noteListName);
                }
                
            } catch (error) {
                alert(`Error loading note list data: ${error.message}`);
            }
        }

        function initializeNewNoteEditor(noteListName) {
            const container = document.getElementById('patch-editor-container');
            
            // Create a new note editor for this patch
            container.innerHTML = `
                <div class="structure-item">
                    <h3>Note Names for ${selectedPatch.name}</h3>
                    <p>Creating new note name list: <strong>${noteListName}</strong></p>
                    
                    <div class="note-editor-controls">
                        <div class="form-group">
                            <label for="note-list-select">Note Name List:</label>
                            <select id="note-list-select">
                                <option value="${noteListName}" selected>${noteListName}</option>
                            </select>
                        </div>
                        
                        <div class="form-group">
                            <button class="btn btn-primary" onclick="addNote()">Add Note</button>
                            <button class="btn btn-secondary" onclick="importNotes()">Import</button>
                            <button class="btn btn-secondary" onclick="exportNotes()">Export</button>
                        </div>
                    </div>
                    
                    <div id="note-editor-content" style="display: block;">
                        <div class="note-editor-header">
                            <h4>Note Mappings</h4>
                            <div class="note-editor-actions">
                                <button class="btn btn-small btn-primary" onclick="addNote()">Add Note</button>
                                <button class="btn btn-small btn-secondary" onclick="importNotes()">Import</button>
                                <button class="btn btn-small btn-secondary" onclick="exportNotes()">Export</button>
                            </div>
                        </div>
                        
                        <div class="note-table-container">
                            <table class="note-table" id="note-table">
                                <thead>
                                    <tr>
                                        <th>Note #</th>
                                        <th>Note Name</th>
                                        <th>Actions</th>
                                    </tr>
                                </thead>
                                <tbody id="note-table-body">
                                </tbody>
                            </table>
                        </div>
                    </div>
                </div>
            `;
            
            // Add a default note to start with
            addNoteRow(36, midiNoteToName(36));
        }

        // Event listeners
        document.getElementById('create-new-device').addEventListener('click', () => {
            if (!selectedManufacturer) {
                alert('Please select a manufacturer first');
                return;
            }
            // TODO: Implement new device creation
            alert(`New device creation for ${selectedManufacturer.name} not yet implemented`);
        });


        function parseMidnamDocument(xmlDoc) {
            // Store the XML document globally for patch loading
            currentMidnam = xmlDoc;
            
            // Update note names for autocomplete with device-specific names
            updateNoteNamesForDevice();
            
            // Find the root MIDINameDocument
            const midnamDoc = xmlDoc.querySelector('MIDINameDocument');
            if (!midnamDoc) {
                console.log('No MIDINameDocument found in XML');
                return;
            }

            // Parse MasterDeviceNames
            const masterDevice = midnamDoc.querySelector('MasterDeviceNames');
            if (masterDevice) {
                const manufacturer = masterDevice.querySelector('Manufacturer')?.textContent;
                const model = masterDevice.querySelector('Model')?.textContent;
                
                if (manufacturer && model) {
                    // Update selected device info
                    document.getElementById('selected-device').textContent = `${manufacturer} ${model}`;
                    document.getElementById('selected-device-notes').textContent = `${manufacturer} ${model}`;
                    
                    // Create a device object for compatibility
                    selectedDevice = {
                        manufacturer: manufacturer,
                        name: model,
                        isDrumMachine: true // D4 is a drum machine
                    };
                }
            }

            // Parse Channel Name Sets
            const channelNameSets = midnamDoc.querySelectorAll('ChannelNameSet');
            channelNameSets.forEach(channelSet => {
                const setName = channelSet.getAttribute('Name');
                if (setName) {
                    addChannelNameSetFromXML(setName, channelSet);
                }
            });

            // Parse Note Name Lists - Skip adding to Device tab since we show them as patch references
            // Note: Note Name Lists are now displayed as references within patches, not as separate sections
            
            // Parse Patch Banks and Patches
            const patchBanks = midnamDoc.querySelectorAll('PatchBank');
            patchBanks.forEach(patchBank => {
                const bankName = patchBank.getAttribute('Name');
                if (bankName) {
                    addPatchBankFromXML(bankName, patchBank);
                }
            });
            
            // Populate patch dropdown after loading structure
            populatePatchDropdown();
        }

        function addChannelNameSetFromXML(setName, channelSet) {
            const container = document.getElementById('channel-name-sets');
            const emptyState = container.querySelector('.empty-state');
            if (emptyState) emptyState.remove();
            
            const nameSetDiv = document.createElement('div');
            nameSetDiv.className = 'structure-element';
            nameSetDiv.innerHTML = `
                <div class="element-header">
                    <span class="element-name">${setName}</span>
                    <div class="element-actions">
                        <button class="btn btn-small btn-secondary" onclick="editChannelNameSet('${setName}')">Edit</button>
                        <button class="btn btn-small btn-danger" onclick="removeChannelNameSet(this)">Remove</button>
                    </div>
                </div>
                <div class="element-content">
                    <p>Loaded from existing .midnam file</p>
                </div>
            `;
            
            container.appendChild(nameSetDiv);
        }

        // Note: addNoteNameListFromXML function removed since Note Name Lists are now shown as patch references
        // instead of separate sections in the Device tab

        function addPatchBankFromXML(bankName, patchBank) {
            const container = document.getElementById('patch-banks');
            const emptyState = container.querySelector('.empty-state');
            if (emptyState) emptyState.remove();
            
            const bankDiv = document.createElement('div');
            bankDiv.className = 'structure-element';
            
            // Count patches in the bank
            const patches = patchBank.querySelectorAll('Patch');
            const patchCount = patches.length;
            
            // Get bank select information
            const bankIndex = Array.from(container.children).length; // Use position as bank index
            const bankSelectInfo = getBankSelectInfo(patchBank, bankIndex);
            
            // Generate bank select display
            let bankSelectHtml = '';
            if (bankSelectInfo.commands.length > 0) {
                const commandsHtml = bankSelectInfo.commands.map(cmd => 
                    `<span class="bank-select-command">CC#${cmd.control}=${cmd.value}</span>`
                ).join('');
                
                bankSelectHtml = `
                    <div class="bank-select-info">
                        <div class="bank-select-status">Bank Select: ${bankSelectInfo.displayText}</div>
                        <div class="bank-select-commands">
                            ${commandsHtml}
                            <button class="bank-select-btn" onclick="sendBankSelectCommands(${JSON.stringify(bankSelectInfo.commands).replace(/"/g, '&quot;')})" title="Send bank select commands">Send</button>
                        </div>
                    </div>
                `;
            } else {
                bankSelectHtml = `
                    <div class="bank-select-info">
                        <div class="bank-select-status">${bankSelectInfo.displayText}</div>
                    </div>
                `;
            }
            
            bankDiv.innerHTML = `
                <div class="element-header">
                    <span class="element-name expandable" onclick="togglePatchBank('${bankName}')">
                        <span class="expand-icon"></span> ${bankName}
                    </span>
                    <div class="element-actions">
                        <button class="btn btn-small btn-secondary" onclick="editPatchBankSettings('${bankName}')">Edit</button>
                        <button class="btn btn-small btn-danger" onclick="removePatchBank(this)">Remove</button>
                    </div>
                </div>
                <div class="bank-select-summary">
                    ${bankSelectInfo.commands.length > 0 ? 
                        `<span class="bank-select-preview">Bank Select: ${bankSelectInfo.displayText}</span>
                         <button class="bank-select-btn btn-small" onclick="sendBankSelectCommands(${JSON.stringify(bankSelectInfo.commands).replace(/"/g, '&quot;')})" title="Send bank select commands">Send</button>` :
                        `<span class="bank-select-preview">${bankSelectInfo.displayText}</span>`
                    }
                </div>
                <div class="element-content" style="display: none;">
                    <p>Loaded from existing .midnam file - ${patchCount} patches</p>
                    ${bankSelectHtml}
                </div>
            `;
            
            container.appendChild(bankDiv);
            
            // Store the patch bank data for later use
            bankDiv.dataset.patchBankData = JSON.stringify({
                name: bankName,
                patchCount: patchCount,
                bankSelectInfo: bankSelectInfo,
                patches: Array.from(patches).map(patch => ({
                    name: patch.getAttribute('Name'),
                    number: patch.getAttribute('Number'),
                    programChange: patch.getAttribute('ProgramChange'),
                    usesNoteList: patch.querySelector('UsesNoteNameList')?.getAttribute('Name')
                }))
            });
        }

        document.getElementById('save-structure').addEventListener('click', () => {
            if (!selectedDevice) {
                alert('Please select a device first');
                return;
            }
            // TODO: Implement structure saving
            alert(`Structure saving for ${selectedDevice.name} not yet implemented`);
        });

        document.getElementById('validate-structure').addEventListener('click', () => {
            if (!selectedDevice) {
                alert('Please select a device first');
                return;
            }
            // TODO: Implement structure validation
            alert(`Structure validation for ${selectedDevice.name} not yet implemented`);
        });

        document.getElementById('save-patch').addEventListener('click', () => {
            if (!selectedPatch) {
                alert('Please select a patch first');
                return;
            }
            
            // Collect note data from the editor
            const noteData = collectNoteDataFromEditor();
            
            if (noteData.length === 0) {
                alert('No notes to save');
                return;
            }
            
            // Save the note data
            saveNoteDataToPatch(selectedPatch, noteData);
        });

        document.getElementById('validate-patch').addEventListener('click', () => {
            if (!selectedPatch) {
                alert('Please select a patch first');
                return;
            }
            // TODO: Implement patch validation
            alert(`Validate patch "${selectedPatch.name}" - Not yet implemented`);
        });
    </script>

    <!-- Hidden keyboard SVG for hover tooltip -->
    <div id="keyboard-tooltip" class="keyboard-tooltip" style="display: none;">
        <img src="assets/kbd.svg" alt="MIDI Keyboard" width="24" height="24">
    </div>
</body>
</html>
